commit 2a2f05aafff78f61fb6e81350944b682d70cf7aa
Author: Alexey Tambovtsev <tambovtsev@list.ru>
Date:   Sun Apr 16 14:18:00 2017 +0300

    genesys_125_start

diff --git a/backend/genesys.c b/backend/genesys.c
index db0a2b2..64bb54d 100644
--- a/backend/genesys.c
+++ b/backend/genesys.c
@@ -3059,11 +3059,13 @@ genesys_send_shading_coefficient (Genesys_Device * dev)
     case CIS_CANONLIDE120:
     case CIS_CANONLIDE210:
     case CIS_CANONLIDE220:
+    case CIS_HPSJ200:
         /* TODO store this in a data struct so we avoid
          * growing this switch */
         if(dev->model->ccd_type!=CIS_CANONLIDE110
         && dev->model->ccd_type!=CIS_CANONLIDE210
         && dev->model->ccd_type!=CIS_CANONLIDE120
+        && dev->model->ccd_type!=CIS_HPSJ200
         && dev->model->ccd_type!=CIS_CANONLIDE220)
           target_code=0xdc00;
         else
@@ -5195,6 +5197,7 @@ calc_parameters (Genesys_Scanner * s)
       || s->dev->model->asic_type == GENESYS_GL124
       || s->dev->model->asic_type == GENESYS_GL845
       || s->dev->model->asic_type == GENESYS_GL846
+      || s->dev->model->asic_type == GENESYS_GL125
       || s->dev->model->asic_type == GENESYS_GL843)
     {
       if (s->dev->settings.xres <= 1200)
@@ -5208,6 +5211,7 @@ calc_parameters (Genesys_Scanner * s)
   if (s->dev->settings.xres >= 1200
       && (    s->dev->model->asic_type == GENESYS_GL124
            || s->dev->model->asic_type == GENESYS_GL847
+       || s->dev->model->asic_type == GENESYS_GL125
            || s->dev->current_setup.xres < s->dev->current_setup.yres
          )
      )
@@ -5876,7 +5880,7 @@ init_options (Genesys_Scanner * s)
   s->opt[OPT_COLOR_FILTER].type = SANE_TYPE_STRING;
   s->opt[OPT_COLOR_FILTER].constraint_type = SANE_CONSTRAINT_STRING_LIST;
   /* true gray not yet supported for GL847 and GL124 scanners */
-  if(!model->is_cis || model->asic_type==GENESYS_GL847 || model->asic_type==GENESYS_GL124)
+  if(!model->is_cis || model->asic_type==GENESYS_GL847 || model->asic_type==GENESYS_GL124 || model->asic_type==GENESYS_GL125)
     {
       s->opt[OPT_COLOR_FILTER].size = max_string_size (color_filter_list);
       s->opt[OPT_COLOR_FILTER].constraint.string_list = color_filter_list;
@@ -6207,8 +6211,15 @@ attach (SANE_String_Const devname, Genesys_Device ** devp, SANE_Bool may_wait)
         }
     }
 
+  i=0;
+  DBG (DBG_info,
+       "attach: genesys_usb_device_list vendor %d product %d\n",
+       vendor, product);
   for (i = 0; i < MAX_SCANNERS && genesys_usb_device_list[i].model != 0; i++)
     {
+      DBG (DBG_info,
+           "attach: genesys_usb_device_list vendor %d product %d\n",
+           vendor, product);
       if (vendor == genesys_usb_device_list[i].vendor &&
 	  product == genesys_usb_device_list[i].product)
 	{
@@ -6216,7 +6227,7 @@ attach (SANE_String_Const devname, Genesys_Device ** devp, SANE_Bool may_wait)
 	  if (!dev)
 	    return SANE_STATUS_NO_MEM;
 	  break;
-	}
+     }
     }
 
   if (!dev)
@@ -7036,9 +7047,7 @@ sane_close (SANE_Handle handle)
   FREE_IFNOT_NULL (s->dev->sensor.gamma_table[1]);
   FREE_IFNOT_NULL (s->dev->sensor.gamma_table[2]);
 
-  s->dev->already_initialized = SANE_FALSE;
-
-   /* for an handful of bytes .. */
+  /* for an handful of bytes .. */
   free ((void *)(size_t)s->opt[OPT_RESOLUTION].constraint.word_list);
   free (s->val[OPT_SOURCE].s);
   free (s->val[OPT_MODE].s);
diff --git a/backend/genesys.conf.in b/backend/genesys.conf.in
index 7899455..1ee210b 100644
--- a/backend/genesys.conf.in
+++ b/backend/genesys.conf.in
@@ -118,6 +118,9 @@ usb 0x03f0 0x4505
 # Hewlett Packard ScanJet G4050
 usb 0x03f0 0x4605
 
+# Hewlett Packard ScanJet 200
+usb 0x03f0 0x1c05
+
 # Plustek OpticBook 3600
 usb 0x07b3 0x0900
 
diff --git a/backend/genesys_devices.c b/backend/genesys_devices.c
index 11f2579..84318a0 100644
--- a/backend/genesys_devices.c
+++ b/backend/genesys_devices.c
@@ -149,6 +149,14 @@ static Genesys_Frontend Wolfson[] = {
    , {0x00, 0x00, 0x00}
    }
   ,
+  {DAC_HPSJ200,
+     {0x9d, 0x91, 0x00, 0x00}
+   , {0x00, 0x00, 0x00}
+   , {0x00, 0x3f, 0x00}  /* 0x00 0x3f 0x00 : offset/brigthness ? */
+   , {0x32, 0x04, 0x00}
+   , {0x00, 0x00, 0x00}
+   }
+  ,
   {DAC_CANONLIDE700,
      {0x9d, 0x9e, 0x00, 0x00}
    , {0x00, 0x00, 0x00}
@@ -749,6 +757,30 @@ static Genesys_Sensor Sensor[] = {
    {2.1, 2.1, 2.1},
    {NULL, NULL, NULL}}
   ,
+  
+  /* HP Scanjet 200 sensor */
+  {CIS_HPSJ200,
+   2400,        /* optical resolution */
+   87,                /* black pixels */
+   16,                /* dummy pixels 16 */
+   303,                /* 303 */
+   5168*4,        /* total pixels */
+   210,
+   200,
+   {0x00, 0x00, 0x00, 0x00},
+   /* reg 0x10 - 0x15 : EXPR, EXPG and EXPB */
+   {0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+   /* reg 0x16 - 0x1d */
+    0x10, 0x04, 0x00, 0x01, 0x30, 0x00, 0x02, 0x01 },
+   /* reg 0x52 - 0x5e */
+   {
+    0x00, 0x02, 0x04, 0x06, 0x04, 0x04, 0x04, 0x04,
+    0x1a, 0x00, 0xc0, 0x00, 0x00
+    }
+   ,
+   {2.1, 2.1, 2.1},
+   {NULL, NULL, NULL}}
+  ,
   {CCD_PLUSTEK_3600,
    1200,
    87,                                /*(black) */
@@ -943,6 +975,11 @@ static Genesys_Gpo Gpo[] = {
    {0xfb, 0x20},        /* 0xfb when idle , 0xf9/0xe9 (1200) when scanning */
    {0xff, 0x00},
   },
+  /* HPSJ200 */
+  {GPO_HPSJ200,
+   {0xfb, 0x20},        /* 0xfb when idle , 0xf9/0xe9 (1200) when scanning */
+   {0xff, 0x00},
+  },
   /* CANONLIDE700 */
   {GPO_CANONLIDE700,
    {0xdb, 0xff},
@@ -1253,6 +1290,20 @@ static Genesys_Motor Motor[] = {
 	   },
     },
   },
+
+  {MOTOR_HPSJ200,                /* HP Scanjet 200 */
+   1200,
+   6400,
+   2,
+   1,
+   { /* motor slopes */
+	   { /* power mode 0 */
+		   {   3000,   1000, 127, 0.50}, /* full step */
+		       {   3000,   1500, 127, 0.50}, /* half step */
+		       { 3*2712, 3*2712, 16, 0.80}, /* quarter step 0.75*2712 */
+	   },
+    },
+  },
   {MOTOR_CANONLIDE700,                /* Canon LiDE 700 */
    1200,
    6400,
@@ -2258,6 +2309,59 @@ static Genesys_Model canon_lide_200_model = {
   400
 };
 
+static Genesys_Model hp_scanjet_200_model = {
+  "hewlett-packard-scanjet-200",                /* Name */
+  "Hewlett Packard",                        /* Device vendor string */
+  "ScanJet 200",                        /* Device model name */
+  GENESYS_GL125,
+  NULL,
+
+  {4800, 2400, 1200, 600, 300, 200, 150, 100, 75, 0},        /* possible x-resolutions */
+  {4800, 2400, 1200, 600, 300, 200, 150, 100, 75, 0},        /* possible y-resolutions */
+  {16, 8, 0},                        /* possible depths in gray mode */
+  {16, 8, 0},                        /* possible depths in color mode */
+
+  SANE_FIX (1.1),                /* Start of scan area in mm  (x) */
+  SANE_FIX (8.3),                /* Start of scan area in mm (y) */
+  SANE_FIX (216.07),                /* Size of scan area in mm (x) */
+  SANE_FIX (299.0),                /* Size of scan area in mm (y) */
+
+  SANE_FIX (0.0),                /* Start of white strip in mm (y) */
+  SANE_FIX (0.0),                /* Start of black mark in mm (x) */
+
+  SANE_FIX (0.0),                /* Start of scan area in TA mode in mm (x) */
+  SANE_FIX (0.0),                /* Start of scan area in TA mode in mm (y) */
+  SANE_FIX (100.0),                /* Size of scan area in TA mode in mm (x) */
+  SANE_FIX (100.0),                /* Size of scan area in TA mode in mm (y) */
+
+  SANE_FIX (0.0),                /* Start of white strip in TA mode in mm (y) */
+
+  SANE_FIX (0.0),                /* Size of scan area after paper sensor stops
+				   sensing document in mm */
+  SANE_FIX (0.0),                /* Amount of feeding needed to eject document
+				   after finishing scanning in mm */
+
+  0, 0, 0,                        /* RGB CCD Line-distance correction in pixel */
+
+  COLOR_ORDER_RGB,                /* Order of the CCD/CIS colors */
+
+  SANE_TRUE,                        /* Is this a CIS scanner? */
+  SANE_FALSE,                        /* Is this a sheetfed scanner? */
+  CIS_HPSJ200,
+  DAC_HPSJ200,
+  GPO_HPSJ200,
+  MOTOR_HPSJ200,
+      GENESYS_FLAG_SKIP_WARMUP
+    | GENESYS_FLAG_SIS_SENSOR
+    | GENESYS_FLAG_OFFSET_CALIBRATION
+    | GENESYS_FLAG_DARK_CALIBRATION
+    | GENESYS_FLAG_SHADING_REPARK
+    | GENESYS_FLAG_CUSTOM_GAMMA,
+  GENESYS_HAS_SCAN_SW | GENESYS_HAS_COPY_SW | GENESYS_HAS_EMAIL_SW | GENESYS_HAS_FILE_SW,
+  50,
+  400
+};
+
 
 static Genesys_Model canon_lide_60_model = {
   "canon-lide-60",                /* Name */
@@ -3694,6 +3798,8 @@ static Genesys_USB_Device_Entry genesys_usb_device_list[] = {
   {0x04a9, 0x1906, &canon_5600f_model},
   {0x04a9, 0x1907, &canon_lide_700f_model},
   {0x03f0, 0x4705, &hpn6310_model},
+  /* GL125 devices */
+  {0x03f0, 0x1c05, &hp_scanjet_200_model},
   /* GL124 devices */
   {0x04a9, 0x1909, &canon_lide_110_model},
   {0x04a9, 0x190e, &canon_lide_120_model},
diff --git a/backend/genesys_gl125.c b/backend/genesys_gl125.c
new file mode 100644
index 0000000..df75790
--- /dev/null
+++ b/backend/genesys_gl125.c
@@ -0,0 +1,3997 @@
+/* sane - Scanner Access Now Easy.
+
+   Copyright (C) 2010-2016 St√©phane Voltz <stef.dev@free.fr>
+
+
+   This file is part of the SANE package.
+
+   This program is free software; you can redistribute it and/or
+   modify it under the terms of the GNU General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA.
+
+   As a special exception, the authors of SANE give permission for
+   additional uses of the libraries contained in this release of SANE.
+
+   The exception is that, if you link a SANE library with other files
+   to produce an executable, this does not by itself cause the
+   resulting executable to be covered by the GNU General Public
+   License.  Your use of that executable is in no way restricted on
+   account of linking the SANE library code into it.
+
+   This exception does not, however, invalidate any other reasons why
+   the executable file might be covered by the GNU General Public
+   License.
+
+   If you submit changes to SANE to the maintainers to be included in
+   a subsequent release, you agree by submitting the changes that
+   those changes may be distributed with this exception intact.
+
+   If you write modifications of your own for SANE, it is your choice
+   whether to permit this exception to apply to your modifications.
+   If you do not wish that, delete this exception notice.
+*/
+
+#undef BACKEND_NAME
+#define BACKEND_NAME genesys_gl125
+
+#include "genesys_gl125.h"
+
+/****************************************************************************
+ Low level function
+ ****************************************************************************/
+
+/* ------------------------------------------------------------------------ */
+/*                  Read and write RAM, registers and AFE                   */
+/* ------------------------------------------------------------------------ */
+
+
+/** @brief read scanned data
+ * Read in 0xeff0 maximum sized blocks. This read is done in 2
+ * parts if not multple of 512. First read is rounded to a multiple of 512 bytes, last read fetches the
+ * remainder. Read addr is always 0x10000000 with the memory layout setup.
+ * @param dev device to read data from
+ * @param addr address within ASIC emory space
+ * @param data pointer where to store the read data
+ * @param len size to read
+ */
+static SANE_Status
+gl125_bulk_read_data (Genesys_Device * dev, uint8_t addr,
+              uint8_t * data, size_t len)
+{
+  SANE_Status status;
+  size_t size, target, read, done;
+  uint8_t outdata[8], *buffer;
+
+  DBG (DBG_io, "gl125_bulk_read_data: requesting %lu bytes (unused addr=0x%02x)\n", (u_long) len,addr);
+
+  if (len == 0)
+    return SANE_STATUS_GOOD;
+
+  target = len;
+  buffer = data;
+
+  /* loop until computed data size is read */
+  while (target)
+    {
+      if (target > 0xeff0)
+    {
+      size = 0xeff0;
+    }
+      else
+    {
+      size = target;
+    }
+
+      /* hard coded 0x10000000 addr */
+      outdata[0] = 0;
+      outdata[1] = 0;
+      outdata[2] = 0;
+      outdata[3] = 0x10;
+
+      /* data size to transfer */
+      outdata[4] = (size & 0xff);
+      outdata[5] = ((size >> 8) & 0xff);
+      outdata[6] = ((size >> 16) & 0xff);
+      outdata[7] = ((size >> 24) & 0xff);
+
+      status =
+    sanei_usb_control_msg (dev->dn, REQUEST_TYPE_OUT, REQUEST_BUFFER,
+                   VALUE_BUFFER, 0x00, sizeof (outdata),
+                   outdata);
+      if (status != SANE_STATUS_GOOD)
+    {
+      DBG (DBG_error, "%s failed while writing command: %s\n",
+           __func__, sane_strstatus (status));
+      return status;
+    }
+
+      /* blocks must be multiple of 512 but not last block */
+      read = size;
+      read /= 512;
+      read *= 512;
+
+      if(read>0)
+        {
+          DBG (DBG_io2,
+               "gl125_bulk_read_data: trying to read %lu bytes of data\n",
+               (u_long) read);
+          status = sanei_usb_read_bulk (dev->dn, data, &read);
+          if (status != SANE_STATUS_GOOD)
+            {
+              DBG (DBG_error,
+                   "gl125_bulk_read_data failed while reading bulk data: %s\n",
+                   sane_strstatus (status));
+              return status;
+            }
+        }
+
+      /* read less than 512 bytes remainder */
+      if (read < size)
+    {
+          done = read;
+      read = size - read;
+      DBG (DBG_io2,
+           "gl125_bulk_read_data: trying to read remaining %lu bytes of data\n",
+           (u_long) read);
+      status = sanei_usb_read_bulk (dev->dn, data+done, &read);
+      if (status != SANE_STATUS_GOOD)
+        {
+          DBG (DBG_error,
+           "gl125_bulk_read_data failed while reading bulk data: %s\n",
+           sane_strstatus (status));
+          return status;
+        }
+    }
+
+      DBG (DBG_io2, "%s: read %lu bytes, %lu remaining\n", __func__,
+       (u_long) size, (u_long) (target - size));
+
+      target -= size;
+      data += size;
+    }
+
+  if (DBG_LEVEL >= DBG_data && dev->binary!=NULL)
+    {
+      fwrite(buffer, len, 1, dev->binary);
+    }
+
+  DBGCOMPLETED;
+
+  return SANE_STATUS_GOOD;
+}
+
+/****************************************************************************
+ Mid level functions
+ ****************************************************************************/
+
+static SANE_Bool
+gl125_get_fast_feed_bit (Genesys_Register_Set * regs)
+{
+  Genesys_Register_Set *r = NULL;
+
+  r = sanei_genesys_get_address (regs, REG02);
+  if (r && (r->value & REG02_FASTFED))
+    return SANE_TRUE;
+  return SANE_FALSE;
+}
+
+static SANE_Bool
+gl125_get_filter_bit (Genesys_Register_Set * regs)
+{
+  Genesys_Register_Set *r = NULL;
+
+  r = sanei_genesys_get_address (regs, REG04);
+  if (r && (r->value & REG04_FILTER))
+    return SANE_TRUE;
+  return SANE_FALSE;
+}
+
+static SANE_Bool
+gl125_get_lineart_bit (Genesys_Register_Set * regs)
+{
+  Genesys_Register_Set *r = NULL;
+
+  r = sanei_genesys_get_address (regs, REG04);
+  if (r && (r->value & REG04_LINEART))
+    return SANE_TRUE;
+  return SANE_FALSE;
+}
+
+static SANE_Bool
+gl125_get_bitset_bit (Genesys_Register_Set * regs)
+{
+  Genesys_Register_Set *r = NULL;
+
+  r = sanei_genesys_get_address (regs, REG04);
+  if (r && (r->value & REG04_BITSET))
+    return SANE_TRUE;
+  return SANE_FALSE;
+}
+
+static SANE_Bool
+gl125_get_gain4_bit (Genesys_Register_Set * regs)
+{
+  Genesys_Register_Set *r = NULL;
+
+  r = sanei_genesys_get_address (regs, REG06);
+  if (r && (r->value & REG06_GAIN4))
+    return SANE_TRUE;
+  return SANE_FALSE;
+}
+
+static SANE_Bool
+gl125_test_buffer_empty_bit (SANE_Byte val)
+{
+  if (val & BUFEMPTY)
+    return SANE_TRUE;
+  return SANE_FALSE;
+}
+
+static SANE_Bool
+gl125_test_motor_flag_bit (SANE_Byte val)
+{
+  if (val & MOTORENB)
+    return SANE_TRUE;
+  return SANE_FALSE;
+}
+
+/** @brief sensor profile
+ * search for the database of motor profiles and get the best one. Each
+ * profile is at a specific dpihw. Use LiDE 110 table by default.
+ * @param sensor_type sensor id
+ * @param dpi hardware dpi for the scan
+ * @param half_ccd flag to signal half ccd mode
+ * @return a pointer to a Sensor_Profile struct
+ */
+static Sensor_Profile *get_sensor_profile(int sensor_type, int dpi, int half_ccd)
+{
+  unsigned int i;
+  int idx;
+
+  i=0;
+  idx=-1;
+  while(i<sizeof(sensors)/sizeof(Sensor_Profile))
+    {
+      /* exact match */
+      if(sensors[i].sensor_type==sensor_type
+         && sensors[i].dpi==dpi
+         && sensors[i].half_ccd==half_ccd)
+        {
+          return &(sensors[i]);
+        }
+
+      /* closest match */
+      if(sensors[i].sensor_type==sensor_type
+        && sensors[i].half_ccd==half_ccd)
+        {
+          if(idx<0)
+            {
+              idx=i;
+            }
+          else
+            {
+              if(sensors[i].dpi>=dpi
+              && sensors[i].dpi<sensors[idx].dpi)
+                {
+                  idx=i;
+                }
+            }
+        }
+      i++;
+    }
+
+  /* default fallback */
+  if(idx<0)
+    {
+      DBG (DBG_warn,"%s: using default sensor profile\n",__func__);
+      idx=0;
+    }
+
+  return &(sensors[idx]);
+}
+
+
+/* returns the max register bulk size */
+static int
+gl125_bulk_full_size (void)
+{
+  return GENESYS_GL125_MAX_REGS;
+}
+
+static SANE_Status
+gl125_homsnr_gpio(Genesys_Device *dev)
+{
+uint8_t val;
+SANE_Status status=SANE_STATUS_GOOD;
+
+  RIE (sanei_genesys_read_register (dev, REG32, &val));
+  val &= ~REG32_GPIO10;
+  RIE (sanei_genesys_write_register (dev, REG32, val));
+  return status;
+}
+
+/**@brief compute half ccd mode
+ * Compute half CCD mode flag. Half CCD is on when dpiset it twice
+ * the actual scanning resolution. Used for fast scans.
+ * @param model pointer to device model
+ * @param xres required horizontal resolution
+ * @return SANE_TRUE if half CCD mode enabled
+ */
+static SANE_Bool compute_half_ccd(Genesys_Model *model, int xres)
+{
+  /* we have 2 domains for ccd: xres below or above half ccd max dpi */
+  if (xres<=300 && (model->flags & GENESYS_FLAG_HALF_CCD_MODE))
+    {
+      return SANE_TRUE;
+    }
+  return SANE_FALSE;
+}
+
+/** @brief set all registers to default values .
+ * This function is called only once at the beginning and
+ * fills register startup values for registers reused across scans.
+ * Those that are rarely modified or not modified are written
+ * individually.
+ * @param dev device structure holding register set to initialize
+ */
+static void
+gl125_init_registers (Genesys_Device * dev)
+{
+  DBGSTART;
+
+  memset (dev->reg, 0, GENESYS_GL125_MAX_REGS * sizeof (Genesys_Register_Set));
+
+  /* default to LiDE 110 */
+  SETREG (0x01,0xa2); /* + REG01_SHDAREA */
+  SETREG (0x02,0x90);
+  SETREG (0x03,0x50);
+  SETREG (0x04,0x03);
+  SETREG (0x05,0x00);
+  if(dev->model->ccd_type==CIS_CANONLIDE120)
+    {
+      SETREG (0x06,0x50);
+      SETREG (0x07,0x00);
+    }
+  else
+    {
+      SETREG (0x03,0x50 & ~REG03_AVEENB);
+      SETREG (0x06,0x50 | REG06_GAIN4);
+    }
+  SETREG (0x09,0x00);
+  SETREG (0x0a,0xc0);
+  SETREG (0x0b,0x2a);
+  SETREG (0x0c,0x12);
+  SETREG (0x11,0x00);
+  SETREG (0x12,0x00);
+  SETREG (0x13,0x0f);
+  SETREG (0x14,0x00);
+  SETREG (0x15,0x80);
+  SETREG (0x16,0x10);
+  SETREG (0x17,0x04);
+  SETREG (0x18,0x00);
+  SETREG (0x19,0x01);
+  SETREG (0x1a,0x30);
+  SETREG (0x1b,0x00);
+  SETREG (0x1c,0x00);
+  SETREG (0x1d,0x01);
+  SETREG (0x1e,0x10);
+  SETREG (0x1f,0x00);
+  SETREG (0x20,0x15);
+  SETREG (0x21,0x00);
+  if(dev->model->ccd_type!=CIS_CANONLIDE120)
+    {
+      SETREG (0x22,0x02);
+    }
+  else
+    {
+      SETREG (0x22,0x14);
+    }
+  SETREG (0x23,0x00);
+  SETREG (0x24,0x00);
+  SETREG (0x25,0x00);
+  SETREG (0x26,0x0d);
+  SETREG (0x27,0x48);
+  SETREG (0x28,0x00);
+  SETREG (0x29,0x56);
+  SETREG (0x2a,0x5e);
+  SETREG (0x2b,0x02);
+  SETREG (0x2c,0x02);
+  SETREG (0x2d,0x58);
+  SETREG (0x3b,0x00);
+  SETREG (0x3c,0x00);
+  SETREG (0x3d,0x00);
+  SETREG (0x3e,0x00);
+  SETREG (0x3f,0x02);
+  SETREG (0x40,0x00);
+  SETREG (0x41,0x00);
+  SETREG (0x42,0x00);
+  SETREG (0x43,0x00);
+  SETREG (0x44,0x00);
+  SETREG (0x45,0x00);
+  SETREG (0x46,0x00);
+  SETREG (0x47,0x00);
+  SETREG (0x48,0x00);
+  SETREG (0x49,0x00);
+  SETREG (0x4f,0x00);
+  SETREG (0x52,0x00);
+  SETREG (0x53,0x02);
+  SETREG (0x54,0x04);
+  SETREG (0x55,0x06);
+  SETREG (0x56,0x04);
+  SETREG (0x57,0x04);
+  SETREG (0x58,0x04);
+  SETREG (0x59,0x04);
+  SETREG (0x5a,0x1a);
+  SETREG (0x5b,0x00);
+  SETREG (0x5c,0xc0);
+  SETREG (0x5f,0x00);
+  SETREG (0x60,0x02);
+  SETREG (0x61,0x00);
+  SETREG (0x62,0x00);
+  SETREG (0x63,0x00);
+  SETREG (0x64,0x00);
+  SETREG (0x65,0x00);
+  SETREG (0x66,0x00);
+  SETREG (0x67,0x00);
+  SETREG (0x68,0x00);
+  SETREG (0x69,0x00);
+  SETREG (0x6a,0x00);
+  SETREG (0x6b,0x00);
+  SETREG (0x6c,0x00);
+  SETREG (0x6e,0x00);
+  SETREG (0x6f,0x00);
+  if(dev->model->ccd_type!=CIS_CANONLIDE120)
+    {
+      SETREG (0x6d,0xd0);
+      SETREG (0x71,0x08);
+    }
+  else
+    {
+      SETREG (0x6d,0x00);
+      SETREG (0x71,0x1f);
+    }
+  SETREG (0x70,0x00);
+  SETREG (0x72,0x08);
+  SETREG (0x73,0x0a);
+
+  /* CKxMAP */
+  SETREG (0x74,0x00);
+  SETREG (0x75,0x00);
+  SETREG (0x76,0x3c);
+  SETREG (0x77,0x00);
+  SETREG (0x78,0x00);
+  SETREG (0x79,0x9f);
+  SETREG (0x7a,0x00);
+  SETREG (0x7b,0x00);
+  SETREG (0x7c,0x55);
+
+  SETREG (0x7d,0x00);
+  SETREG (0x7e,0x08);
+  SETREG (0x7f,0x58);
+  if(dev->model->ccd_type!=CIS_CANONLIDE120)
+    {
+      SETREG (0x80,0x00);
+      SETREG (0x81,0x14);
+    }
+  else
+    {
+      SETREG (0x80,0x00);
+      SETREG (0x81,0x10);
+    }
+
+  /* STRPIXEL */
+  SETREG (0x82,0x00);
+  SETREG (0x83,0x00);
+  SETREG (0x84,0x00);
+  /* ENDPIXEL */
+  SETREG (0x85,0x00);
+  SETREG (0x86,0x00);
+  SETREG (0x87,0x00);
+
+  SETREG (0x88,0x00);
+  SETREG (0x89,0x65);
+  SETREG (0x8a,0x00);
+  SETREG (0x8b,0x00);
+  SETREG (0x8c,0x00);
+  SETREG (0x8d,0x00);
+  SETREG (0x8e,0x00);
+  SETREG (0x8f,0x00);
+  SETREG (0x90,0x00);
+  SETREG (0x91,0x00);
+  SETREG (0x92,0x00);
+  SETREG (0x93,0x00);
+  SETREG (0x94,0x14);
+  SETREG (0x95,0x30);
+  SETREG (0x96,0x00);
+  SETREG (0x97,0x90);
+  SETREG (0x98,0x01);
+  SETREG (0x99,0x1f);
+  SETREG (0x9a,0x00);
+  SETREG (0x9b,0x80);
+  SETREG (0x9c,0x80);
+  SETREG (0x9d,0x3f);
+  SETREG (0x9e,0x00);
+  SETREG (0x9f,0x00);
+  SETREG (0xa0,0x20);
+  SETREG (0xa1,0x30);
+  SETREG (0xa2,0x00);
+  SETREG (0xa3,0x20);
+  SETREG (0xa4,0x01);
+  SETREG (0xa5,0x00);
+  SETREG (0xa6,0x00);
+  SETREG (0xa7,0x08);
+  SETREG (0xa8,0x00);
+  SETREG (0xa9,0x08);
+  SETREG (0xaa,0x01);
+  SETREG (0xab,0x00);
+  SETREG (0xac,0x00);
+  SETREG (0xad,0x40);
+  SETREG (0xae,0x01);
+  SETREG (0xaf,0x00);
+  SETREG (0xb0,0x00);
+  SETREG (0xb1,0x40);
+  SETREG (0xb2,0x00);
+  SETREG (0xb3,0x09);
+  SETREG (0xb4,0x5b);
+  SETREG (0xb5,0x00);
+  SETREG (0xb6,0x10);
+  SETREG (0xb7,0x3f);
+  SETREG (0xb8,0x00);
+  SETREG (0xbb,0x00);
+  SETREG (0xbc,0xff);
+  SETREG (0xbd,0x00);
+  SETREG (0xbe,0x07);
+  SETREG (0xc3,0x00);
+  SETREG (0xc4,0x00);
+
+  /* gamma
+  SETREG (0xc5,0x00);
+  SETREG (0xc6,0x00);
+  SETREG (0xc7,0x00);
+  SETREG (0xc8,0x00);
+  SETREG (0xc9,0x00);
+  SETREG (0xca,0x00);
+  SETREG (0xcb,0x00);
+  SETREG (0xcc,0x00);
+  SETREG (0xcd,0x00);
+  SETREG (0xce,0x00);
+  */
+  if(dev->model->ccd_type==CIS_CANONLIDE120)
+    {
+      SETREG (0xc5,0x20);
+      SETREG (0xc6,0xeb);
+      SETREG (0xc7,0x20);
+      SETREG (0xc8,0xeb);
+      SETREG (0xc9,0x20);
+      SETREG (0xca,0xeb);
+    }
+
+  /* memory layout
+  SETREG (0xd0,0x0a);
+  SETREG (0xd1,0x1f);
+  SETREG (0xd2,0x34); */
+  SETREG (0xd3,0x00);
+  SETREG (0xd4,0x00);
+  SETREG (0xd5,0x00);
+  SETREG (0xd6,0x00);
+  SETREG (0xd7,0x00);
+  SETREG (0xd8,0x00);
+  SETREG (0xd9,0x00);
+
+  /* memory layout
+  SETREG (0xe0,0x00);
+  SETREG (0xe1,0x48);
+  SETREG (0xe2,0x15);
+  SETREG (0xe3,0x90);
+  SETREG (0xe4,0x15);
+  SETREG (0xe5,0x91);
+  SETREG (0xe6,0x2a);
+  SETREG (0xe7,0xd9);
+  SETREG (0xe8,0x2a);
+  SETREG (0xe9,0xad);
+  SETREG (0xea,0x40);
+  SETREG (0xeb,0x22);
+  SETREG (0xec,0x40);
+  SETREG (0xed,0x23);
+  SETREG (0xee,0x55);
+  SETREG (0xef,0x6b);
+  SETREG (0xf0,0x55);
+  SETREG (0xf1,0x6c);
+  SETREG (0xf2,0x6a);
+  SETREG (0xf3,0xb4);
+  SETREG (0xf4,0x6a);
+  SETREG (0xf5,0xb5);
+  SETREG (0xf6,0x7f);
+  SETREG (0xf7,0xfd);*/
+
+  SETREG (0xf8,0x01);   /* other value is 0x05 */
+  SETREG (0xf9,0x00);
+  SETREG (0xfa,0x00);
+  SETREG (0xfb,0x00);
+  SETREG (0xfc,0x00);
+  SETREG (0xff,0x00);
+
+  /* fine tune upon device description */
+  dev->reg[reg_0x05].value &= ~REG05_DPIHW;
+  switch (dev->sensor.optical_res)
+    {
+    case 600:
+      dev->reg[reg_0x05].value |= REG05_DPIHW_600;
+      break;
+    case 1200:
+      dev->reg[reg_0x05].value |= REG05_DPIHW_1200;
+      break;
+    case 2400:
+      dev->reg[reg_0x05].value |= REG05_DPIHW_2400;
+      break;
+    case 4800:
+      dev->reg[reg_0x05].value |= REG05_DPIHW_4800;
+      break;
+    }
+
+  /* initalize calibration reg */
+  memcpy (dev->calib_reg, dev->reg,
+      GENESYS_GL125_MAX_REGS * sizeof (Genesys_Register_Set));
+
+  DBGCOMPLETED;
+}
+
+/**@brief send slope table for motor movement
+ * Send slope_table in machine byte order
+ * @param dev device to send slope table
+ * @param table_nr index of the slope table in ASIC memory
+ * Must be in the [0-4] range.
+ * @param slope_table pointer to 16 bit values array of the slope table
+ * @param steps number of elemnts in the slope table
+ */
+GENESYS_STATIC SANE_Status
+gl125_send_slope_table (Genesys_Device * dev, int table_nr,
+            uint16_t * slope_table, int steps)
+{
+  SANE_Status status;
+  uint8_t *table;
+  int i;
+  char msg[10000];
+
+  DBG (DBG_proc, "%s (table_nr = %d, steps = %d)\n", __func__,
+       table_nr, steps);
+
+  /* sanity check */
+  if(table_nr<0 || table_nr>4)
+    {
+      DBG (DBG_error, "%s: invalid table number %d!\n", __func__, table_nr);
+      return SANE_STATUS_INVAL;
+    }
+
+  table = (uint8_t *) malloc (steps * 2);
+  for (i = 0; i < steps; i++)
+    {
+      table[i * 2] = slope_table[i] & 0xff;
+      table[i * 2 + 1] = slope_table[i] >> 8;
+    }
+
+  if (DBG_LEVEL >= DBG_io)
+    {
+      sprintf (msg, "write slope %d (%d)=", table_nr, steps);
+      for (i = 0; i < steps; i++)
+    {
+      sprintf (msg+strlen(msg), ",%d", slope_table[i]);
+    }
+      DBG (DBG_io, "%s: %s\n", __func__, msg);
+    }
+
+  /* slope table addresses are fixed */
+  status =
+    sanei_genesys_write_ahb (dev->dn, dev->usb_mode, 0x10000000 + 0x4000 * table_nr, steps * 2, table);
+  if (status != SANE_STATUS_GOOD)
+    {
+      DBG (DBG_error,
+       "%s: write to AHB failed writing slope table %d (%s)\n",
+       __func__, table_nr, sane_strstatus (status));
+    }
+
+  free (table);
+  DBGCOMPLETED;
+  return status;
+}
+
+/** @brief * Set register values of 'special' ti type frontend
+ * Registers value are taken from the frontend register data
+ * set.
+ * @param dev device owning the AFE
+ * @param set flag AFE_INIT to specify the AFE must be reset before writing data
+ * */
+static SANE_Status
+gl125_set_ti_fe (Genesys_Device * dev, uint8_t set)
+{
+  SANE_Status status = SANE_STATUS_GOOD;
+  int i;
+  uint16_t val;
+
+  DBGSTART;
+  if (set == AFE_INIT)
+    {
+      DBG (DBG_proc, "%s: setting DAC %u\n", __func__, dev->model->dac_type);
+
+      /* sets to default values */
+      sanei_genesys_init_fe (dev);
+    }
+
+  /* start writing to DAC */
+  status = sanei_genesys_fe_write_data (dev, 0x00, 0x80);
+  if (status != SANE_STATUS_GOOD)
+    {
+      DBG (DBG_error, "%s: failed to write reg0: %s\n", __func__,
+       sane_strstatus (status));
+      return status;
+    }
+
+  /* write values to analog frontend */
+  for (i = 1; i < 4; i++)
+    {
+      val = dev->frontend.reg[i];
+      status = sanei_genesys_fe_write_data (dev, i, val);
+      if (status != SANE_STATUS_GOOD)
+    {
+      DBG (DBG_error,
+           "%s: failed to write reg %d: %s\n", __func__, i,
+           sane_strstatus (status));
+      return status;
+    }
+    }
+
+  status = sanei_genesys_fe_write_data (dev, 0x04, 0x00);
+  if (status != SANE_STATUS_GOOD)
+    {
+      DBG (DBG_error, "%s: failed to write reg4: %s\n", __func__,
+       sane_strstatus (status));
+      return status;
+    }
+
+  /* these are not really sign for this AFE */
+  for (i = 0; i < 3; i++)
+    {
+      val = dev->frontend.sign[i];
+      status = sanei_genesys_fe_write_data (dev, 0x05 + i, val);
+      if (status != SANE_STATUS_GOOD)
+    {
+      DBG (DBG_error,
+           "%s: failed to write reg %d: %s\n", __func__, i+5,
+           sane_strstatus (status));
+      return status;
+    }
+    }
+
+  /* close writing to DAC */
+  if(dev->model->dac_type == DAC_CANONLIDE120)
+    {
+      status = sanei_genesys_fe_write_data (dev, 0x00, 0x01);
+    }
+  else
+    {
+      status = sanei_genesys_fe_write_data (dev, 0x00, 0x11);
+    }
+  if (status != SANE_STATUS_GOOD)
+    {
+      DBG (DBG_error, "%s: failed to write reg0: %s\n", __func__,
+       sane_strstatus (status));
+      return status;
+    }
+
+  DBGCOMPLETED;
+
+  return status;
+}
+
+
+/* Set values of analog frontend */
+static SANE_Status
+gl125_set_fe (Genesys_Device * dev, uint8_t set)
+{
+  SANE_Status status;
+  uint8_t val;
+
+  DBG (DBG_proc, "gl125_set_fe (%s)\n",
+       set == AFE_INIT ? "init" : set == AFE_SET ? "set" : set ==
+       AFE_POWER_SAVE ? "powersave" : "huh?");
+
+  if (set == AFE_INIT)
+    {
+      DBG (DBG_proc, "gl125_set_fe(): setting DAC %u\n",
+       dev->model->dac_type);
+      sanei_genesys_init_fe (dev);
+    }
+
+  RIE (sanei_genesys_read_register (dev, REG0A, &val));
+
+  if(dev->usb_mode<0)
+    {
+      val=3<<REG0AS_SIFSEL;
+    }
+
+  /* route to correct analog FE */
+  switch ((val & REG0A_SIFSEL)>>REG0AS_SIFSEL)
+    {
+    case 3:
+      status=gl125_set_ti_fe (dev, set);
+      break;
+    case 0:
+    case 1:
+    case 2:
+    default:
+      DBG (DBG_error, "%s: unsupported analog FE 0x%02x\n",__func__,val);
+      status=SANE_STATUS_INVAL;
+      break;
+    }
+
+  DBGCOMPLETED;
+  return status;
+}
+
+
+/**@brief compute exposure to use
+ * compute the sensor exposure based on target resolution
+ * @param dev pointer to  device description
+ * @param xres sensor's required resolution
+ * @param half_ccd flag for half ccd mode
+ */
+static int gl125_compute_exposure(Genesys_Device *dev, int xres, int half_ccd)
+{
+  Sensor_Profile *sensor;
+
+  sensor=get_sensor_profile(dev->model->ccd_type, xres, half_ccd);
+  return sensor->exposure;
+}
+
+
+static SANE_Status
+gl125_init_motor_regs_scan (Genesys_Device * dev,
+                            Genesys_Register_Set * reg,
+                            unsigned int scan_exposure_time,
+                float scan_yres,
+                int scan_step_type,
+                unsigned int scan_lines,
+                unsigned int scan_dummy,
+                unsigned int feed_steps,
+                int scan_mode,
+                            unsigned int flags)
+{
+  SANE_Status status;
+  int use_fast_fed;
+  unsigned int lincnt, fast_dpi;
+  uint16_t scan_table[SLOPE_TABLE_SIZE];
+  uint16_t fast_table[SLOPE_TABLE_SIZE];
+  int scan_steps,fast_steps,factor;
+  unsigned int feedl,dist;
+  Genesys_Register_Set *r;
+  uint32_t z1, z2;
+  float yres;
+  int min_speed;
+  unsigned int linesel;
+
+  DBGSTART;
+  DBG (DBG_info, "gl125_init_motor_regs_scan : scan_exposure_time=%d, "
+       "scan_yres=%g, scan_step_type=%d, scan_lines=%d, scan_dummy=%d, "
+       "feed_steps=%d, scan_mode=%d, flags=%x\n",
+       scan_exposure_time,
+       scan_yres,
+       scan_step_type,
+       scan_lines, scan_dummy, feed_steps, scan_mode, flags);
+
+  /* we never use fast fed since we do manual feed for the scans */
+  use_fast_fed=0;
+  factor=1;
+
+  /* enforce motor minimal scan speed
+   * @TODO extend motor struct for this value */
+  if (scan_mode == SCAN_MODE_COLOR)
+    {
+      min_speed = 900;
+    }
+  else
+    {
+      switch(dev->model->motor_type)
+        {
+          case MOTOR_CANONLIDE110:
+        min_speed = 600;
+            break;
+          case MOTOR_CANONLIDE120:
+            min_speed = 900;
+            break;
+          default:
+            min_speed = 900;
+            break;
+        }
+    }
+
+  /* compute min_speed and linesel */
+  if(scan_yres<min_speed)
+    {
+      yres=min_speed;
+      linesel=yres/scan_yres-1;
+      /* limit case, we need a linesel > 0 */
+      if(linesel==0)
+        {
+          linesel=1;
+          yres=scan_yres*2;
+        }
+    }
+  else
+    {
+      yres=scan_yres;
+      linesel=0;
+    }
+
+  DBG (DBG_io2, "%s: final yres=%f, linesel=%d\n", __func__, yres, linesel);
+
+  lincnt=scan_lines*(linesel+1);
+  sanei_genesys_set_triple(reg,REG_LINCNT,lincnt);
+  DBG (DBG_io, "%s: lincnt=%d\n", __func__, lincnt);
+
+  /* compute register 02 value */
+  r = sanei_genesys_get_address (reg, REG02);
+  r->value = REG02_NOTHOME;
+  r->value |= REG02_MTRPWR;
+
+  if (use_fast_fed)
+    r->value |= REG02_FASTFED;
+  else
+    r->value &= ~REG02_FASTFED;
+
+  if (flags & MOTOR_FLAG_AUTO_GO_HOME)
+    r->value |= REG02_AGOHOME;
+
+  if ((flags & MOTOR_FLAG_DISABLE_BUFFER_FULL_MOVE)
+    ||(yres>=dev->sensor.optical_res))
+    r->value |= REG02_ACDCDIS;
+
+  /* SCANFED */
+  sanei_genesys_set_double(reg,REG_SCANFED,4);
+
+  /* scan and backtracking slope table */
+  sanei_genesys_slope_table(scan_table,
+                            &scan_steps,
+                            yres,
+                            scan_exposure_time,
+                            dev->motor.base_ydpi,
+                            scan_step_type,
+                            factor,
+                            dev->model->motor_type,
+                            motors);
+  RIE(gl125_send_slope_table (dev, SCAN_TABLE, scan_table, scan_steps));
+  RIE(gl125_send_slope_table (dev, BACKTRACK_TABLE, scan_table, scan_steps));
+
+  /* STEPNO */
+  sanei_genesys_set_double(reg,REG_STEPNO,scan_steps);
+
+  /* fast table */
+  fast_dpi=yres;
+
+  /*
+  if (scan_mode != SCAN_MODE_COLOR)
+    {
+      fast_dpi*=3;
+    }
+    */
+  sanei_genesys_slope_table(fast_table,
+                            &fast_steps,
+                            fast_dpi,
+                            scan_exposure_time,
+                            dev->motor.base_ydpi,
+                            scan_step_type,
+                            factor,
+                            dev->model->motor_type,
+                            motors);
+  RIE(gl125_send_slope_table (dev, STOP_TABLE, fast_table, fast_steps));
+  RIE(gl125_send_slope_table (dev, FAST_TABLE, fast_table, fast_steps));
+
+  /* FASTNO */
+  sanei_genesys_set_double(reg,REG_FASTNO,fast_steps);
+
+  /* FSHDEC */
+  sanei_genesys_set_double(reg,REG_FSHDEC,fast_steps);
+
+  /* FMOVNO */
+  sanei_genesys_set_double(reg,REG_FMOVNO,fast_steps);
+
+  /* substract acceleration distance from feedl */
+  feedl=feed_steps;
+  feedl<<=scan_step_type;
+
+  dist = scan_steps;
+  if (flags & MOTOR_FLAG_FEED)
+    dist *=2;
+  if (use_fast_fed)
+    {
+        dist += fast_steps*2;
+    }
+  DBG (DBG_io2, "%s: acceleration distance=%d\n", __func__, dist);
+
+  /* get sure we don't use insane value */
+  if(dist<feedl)
+    feedl -= dist;
+  else
+    feedl = 0;
+
+  sanei_genesys_set_triple(reg,REG_FEEDL,feedl);
+  DBG (DBG_io, "%s: feedl=%d\n", __func__, feedl);
+
+  /* doesn't seem to matter that much */
+  sanei_genesys_calculate_zmode2 (use_fast_fed,
+                  scan_exposure_time,
+                  scan_table,
+                  scan_steps,
+                  feedl,
+                                  scan_steps,
+                                  &z1,
+                                  &z2);
+
+  sanei_genesys_set_triple(reg,REG_Z1MOD,z1);
+  DBG (DBG_info, "gl125_init_motor_regs_scan: z1 = %d\n", z1);
+
+  sanei_genesys_set_triple(reg,REG_Z2MOD,z2);
+  DBG (DBG_info, "gl125_init_motor_regs_scan: z2 = %d\n", z2);
+
+  /* LINESEL */
+  r = sanei_genesys_get_address (reg, REG1D);
+  r->value = (r->value & ~REG1D_LINESEL) | linesel;
+
+  r = sanei_genesys_get_address (reg, REGA0);
+  r->value = (scan_step_type << REGA0S_STEPSEL) | (scan_step_type << REGA0S_FSTPSEL);
+
+  /* FMOVDEC */
+  sanei_genesys_set_double(reg,REG_FMOVDEC,fast_steps);
+
+  DBGCOMPLETED;
+  return SANE_STATUS_GOOD;
+}
+
+
+/** @brief copy sensor specific settings
+ * Set up register set for the given sensor resolution. Values are from the device table
+ * in genesys_devices.c for registers:
+ *       [0x16 ... 0x1d]
+ *       [0x52 ... 0x5e]
+ * Other come from the specific device sensor table in genesys_gl125.h:
+ *      0x18, 0x20, 0x61, 0x98 and
+ * @param dev device to set up
+ * @param regs register set to modify
+ * @param dpi resolution of the sensor during scan
+ * @param half_ccd flag for half ccd mode
+ * */
+static void
+gl125_setup_sensor (Genesys_Device * dev, Genesys_Register_Set * regs, int dpi, int half_ccd)
+{
+  Genesys_Register_Set *r;
+  int i;
+  Sensor_Profile *sensor;
+  int dpihw;
+  uint32_t exp;
+
+  DBGSTART;
+
+  /* we start at 6, 0-5 is a 16 bits cache for exposure */
+  for (i = 0x06; i < 0x0e; i++)
+    {
+      r = sanei_genesys_get_address (regs, 0x10 + i);
+      if (r)
+    {
+      r->value = dev->sensor.regs_0x10_0x1d[i];
+    }
+    }
+
+  /* skip writing 5d,5e which is AFE address because
+   * they are not deifned in register set */
+  for (i = 0; i < 11; i++)
+    {
+      r = sanei_genesys_get_address (regs, 0x52 + i);
+      if (r)
+    {
+      r->value = dev->sensor.regs_0x52_0x5e[i];
+    }
+    }
+
+  /* set EXPDUMMY and CKxMAP */
+  dpihw=sanei_genesys_compute_dpihw(dev,dpi);
+  sensor=get_sensor_profile(dev->model->ccd_type, dpihw, half_ccd);
+
+  r = sanei_genesys_get_address (regs, 0x18);
+  if (r)
+    {
+      r->value = sensor->reg18;
+    }
+  r = sanei_genesys_get_address (regs, 0x20);
+  if (r)
+    {
+      r->value = sensor->reg20;
+    }
+  r = sanei_genesys_get_address (regs, 0x61);
+  if (r)
+    {
+      r->value = sensor->reg61;
+    }
+  r = sanei_genesys_get_address (regs, 0x98);
+  if (r)
+    {
+      r->value = sensor->reg98;
+    }
+
+  if(sensor->reg16!=0)
+    {
+      r = sanei_genesys_get_address (regs, 0x16);
+      if (r)
+    {
+      r->value = sensor->reg16;
+    }
+    }
+  if(sensor->reg70!=0)
+    {
+      r = sanei_genesys_get_address (regs, 0x70);
+      if (r)
+    {
+      r->value = sensor->reg70;
+    }
+    }
+
+  sanei_genesys_set_triple(regs,REG_SEGCNT,sensor->segcnt);
+  sanei_genesys_set_double(regs,REG_TG0CNT,sensor->tg0cnt);
+  sanei_genesys_set_double(regs,REG_EXPDMY,sensor->expdummy);
+
+  /* if no calibration has been done, set default values for exposures */
+  exp=dev->sensor.regs_0x10_0x1d[0]*256+dev->sensor.regs_0x10_0x1d[1];
+  if(exp==0)
+    {
+      exp=sensor->expr;
+    }
+  sanei_genesys_set_triple(regs,REG_EXPR,exp);
+
+  exp=dev->sensor.regs_0x10_0x1d[2]*256+dev->sensor.regs_0x10_0x1d[3];
+  if(exp==0)
+    {
+      exp=sensor->expg;
+    }
+  sanei_genesys_set_triple(regs,REG_EXPG,exp);
+
+  exp=dev->sensor.regs_0x10_0x1d[4]*256+dev->sensor.regs_0x10_0x1d[5];
+  if(exp==0)
+    {
+      exp=sensor->expb;
+    }
+  sanei_genesys_set_triple(regs,REG_EXPB,exp);
+
+  sanei_genesys_set_triple(regs,REG_CK1MAP,sensor->ck1map);
+  sanei_genesys_set_triple(regs,REG_CK3MAP,sensor->ck3map);
+  sanei_genesys_set_triple(regs,REG_CK4MAP,sensor->ck4map);
+
+  /* order of the sub-segments */
+  dev->order=sensor->order;
+
+  DBGCOMPLETED;
+}
+
+/** @brief setup optical related registers
+ * start and pixels are expressed in optical sensor resolution coordinate
+ * space.
+ * @param dev scanner device to use
+ * @param reg registers to set up
+ * @param exposure_time exposure time to use
+ * @param used_res scanning resolution used, may differ from
+ *        scan's one
+ * @param start logical start pixel coordinate
+ * @param pixels logical number of pixels to use
+ * @param channels number of color channels (currently 1 or 3)
+ * @param depth bit depth of the scan (1, 8 or 16)
+ * @param half_ccd SANE_TRUE if sensor's timings are such that x coordinates
+ *           must be halved
+ * @param color_filter color channel to use as gray data
+ * @param flags optical flags (@see )
+ * @return SANE_STATUS_GOOD if OK
+ */
+static SANE_Status
+gl125_init_optical_regs_scan (Genesys_Device * dev,
+                  Genesys_Register_Set * reg,
+                  unsigned int exposure_time,
+                  int used_res,
+                  unsigned int start,
+                  unsigned int pixels,
+                  int channels,
+                  int depth,
+                  SANE_Bool half_ccd,
+                              int color_filter,
+                              int flags)
+{
+  unsigned int words_per_line, segcnt;
+  unsigned int startx, endx, used_pixels, segnb;
+  unsigned int dpiset, cksel, dpihw, factor;
+  unsigned int bytes;
+  Genesys_Register_Set *r;
+  SANE_Status status;
+  uint32_t expmax, exp;
+
+  DBG (DBG_proc, "%s :  exposure_time=%d, "
+       "used_res=%d, start=%d, pixels=%d, channels=%d, depth=%d, "
+       "half_ccd=%d, flags=%x\n", __func__, exposure_time,
+       used_res, start, pixels, channels, depth, half_ccd, flags);
+
+  /* resolution is divided according to CKSEL */
+  r = sanei_genesys_get_address (reg, REG18);
+  cksel= (r->value & REG18_CKSEL)+1;
+  DBG (DBG_io2, "%s: cksel=%d\n", __func__, cksel);
+
+  /* to manage high resolution device while keeping good
+   * low resolution scanning speed, we make hardware dpi vary */
+  dpihw=sanei_genesys_compute_dpihw(dev, used_res * cksel);
+  factor=dev->sensor.optical_res/dpihw;
+  DBG (DBG_io2, "%s: dpihw=%d (factor=%d)\n", __func__, dpihw, factor);
+
+  /* sensor parameters */
+  gl125_setup_sensor (dev, reg, dpihw, half_ccd);
+  dpiset = used_res * cksel;
+
+  /* start and end coordinate in optical dpi coordinates */
+  /* startx = start/cksel + dev->sensor.dummy_pixel; XXX STEF XXX */
+  startx = start/cksel;
+  used_pixels=pixels/cksel;
+  endx = startx + used_pixels;
+
+  /* pixel coordinate factor correction when used dpihw is not maximal one */
+  startx/=factor;
+  endx/=factor;
+  used_pixels=endx-startx;
+
+  status = gl125_set_fe (dev, AFE_SET);
+  if (status != SANE_STATUS_GOOD)
+    {
+      DBG (DBG_error, "%s: failed to set frontend: %s\n", __func__,
+       sane_strstatus (status));
+      return status;
+    }
+
+  /* enable shading */
+  r = sanei_genesys_get_address (reg, REG01);
+  r->value &= ~REG01_SCAN;
+  if ((flags & OPTICAL_FLAG_DISABLE_SHADING) ||
+      (dev->model->flags & GENESYS_FLAG_NO_CALIBRATION))
+    {
+      r->value &= ~REG01_DVDSET;
+    }
+  else
+    {
+      r->value |= REG01_DVDSET;
+    }
+  r->value &= ~REG01_SCAN;
+
+  r = sanei_genesys_get_address (reg, REG03);
+  if((dev->model->ccd_type!=CIS_CANONLIDE120)&&(used_res>=600))
+    {
+      r->value &= ~REG03_AVEENB;
+      DBG (DBG_io, "%s: disabling AVEENB\n", __func__);
+    }
+  else
+    {
+      r->value |= ~REG03_AVEENB;
+      DBG (DBG_io, "%s: enabling AVEENB\n", __func__);
+    }
+
+  if (flags & OPTICAL_FLAG_DISABLE_LAMP)
+    r->value &= ~REG03_LAMPPWR;
+  else
+    r->value |= REG03_LAMPPWR;
+
+  /* BW threshold */
+  RIE (sanei_genesys_write_register (dev, REG114, dev->settings.threshold));
+  RIE (sanei_genesys_write_register (dev, REG115, dev->settings.threshold));
+
+  /* monochrome / color scan */
+  r = sanei_genesys_get_address (reg, REG04);
+  switch (depth)
+    {
+    case 1:
+      r->value &= ~REG04_BITSET;
+      r->value |= REG04_LINEART;
+      break;
+    case 8:
+      r->value &= ~(REG04_LINEART | REG04_BITSET);
+      break;
+    case 16:
+      r->value &= ~REG04_LINEART;
+      r->value |= REG04_BITSET;
+      break;
+    }
+
+  r->value &= ~REG04_FILTER;
+  if (channels == 1)
+    {
+      switch (color_filter)
+    {
+    case 0:
+      r->value |= 0x10;        /* red filter */
+      break;
+    case 2:
+      r->value |= 0x30;        /* blue filter */
+      break;
+    default:
+      r->value |= 0x20;        /* green filter */
+      break;
+    }
+    }
+
+  /* register 05 */
+  r = sanei_genesys_get_address (reg, REG05);
+
+  /* set up dpihw */
+  r->value &= ~REG05_DPIHW;
+  switch(dpihw)
+    {
+      case 600:
+        r->value |= REG05_DPIHW_600;
+        break;
+      case 1200:
+        r->value |= REG05_DPIHW_1200;
+        break;
+      case 2400:
+        r->value |= REG05_DPIHW_2400;
+        break;
+      case 4800:
+        r->value |= REG05_DPIHW_4800;
+        break;
+    }
+
+  /* enable gamma tables */
+  if (flags & OPTICAL_FLAG_DISABLE_GAMMA)
+    r->value &= ~REG05_GMMENB;
+  else
+    r->value |= REG05_GMMENB;
+
+  if(half_ccd)
+    {
+      sanei_genesys_set_double(reg,REG_DPISET,dpiset*2);
+      DBG (DBG_io2, "%s: dpiset used=%d\n", __func__, dpiset*2);
+    }
+  else
+    {
+      sanei_genesys_set_double(reg,REG_DPISET,dpiset);
+      DBG (DBG_io2, "%s: dpiset used=%d\n", __func__, dpiset);
+    }
+
+  r = sanei_genesys_get_address (reg, REG06);
+  r->value |= REG06_GAIN4;
+
+  /* CIS scanners can do true gray by setting LEDADD */
+  /* we set up LEDADD only when asked */
+  if (dev->model->is_cis == SANE_TRUE)
+    {
+      r = sanei_genesys_get_address (reg, REG60);
+      r->value &= ~REG60_LEDADD;
+      if (channels == 1 && (flags & OPTICAL_FLAG_ENABLE_LEDADD))
+    {
+      r->value |= REG60_LEDADD;
+          sanei_genesys_get_triple(reg,REG_EXPR,&expmax);
+          sanei_genesys_get_triple(reg,REG_EXPG,&exp);
+          if(exp>expmax)
+            {
+              expmax=exp;
+            }
+          sanei_genesys_get_triple(reg,REG_EXPB,&exp);
+          if(exp>expmax)
+            {
+              expmax=exp;
+            }
+          sanei_genesys_set_triple(dev->reg,REG_EXPR,expmax);
+          sanei_genesys_set_triple(dev->reg,REG_EXPG,expmax);
+          sanei_genesys_set_triple(dev->reg,REG_EXPB,expmax);
+    }
+      /* RGB weighting, REG_TRUER,G and B are to be set  */
+      r = sanei_genesys_get_address (reg, 0x01);
+      r->value &= ~REG01_TRUEGRAY;
+      if (channels == 1 && (flags & OPTICAL_FLAG_ENABLE_LEDADD))
+    {
+      r->value |= REG01_TRUEGRAY;
+          sanei_genesys_write_register (dev, REG_TRUER, 0x80);
+          sanei_genesys_write_register (dev, REG_TRUEG, 0x80);
+          sanei_genesys_write_register (dev, REG_TRUEB, 0x80);
+    }
+    }
+
+  /* segment number */
+  r = sanei_genesys_get_address (reg, 0x98);
+  segnb = r->value & 0x0f;
+
+  sanei_genesys_set_triple(reg,REG_STRPIXEL,startx/segnb);
+  DBG (DBG_io2, "%s: strpixel used=%d\n", __func__, startx/segnb);
+  sanei_genesys_get_triple(reg,REG_SEGCNT,&segcnt);
+  if(endx/segnb==segcnt)
+    {
+      endx=0;
+    }
+  sanei_genesys_set_triple(reg,REG_ENDPIXEL,endx/segnb);
+  DBG (DBG_io2, "%s: endpixel used=%d\n", __func__, endx/segnb);
+
+  /* words(16bit) before gamma, conversion to 8 bit or lineart */
+  words_per_line = (used_pixels * dpiset) / dpihw;
+  bytes = depth / 8;
+  if (depth == 1)
+    {
+      words_per_line = (words_per_line >> 3) + ((words_per_line & 7) ? 1 : 0);
+    }
+  else
+    {
+      words_per_line *= bytes;
+    }
+
+  dev->bpl = words_per_line;
+  dev->cur = 0;
+  dev->skip = 0;
+  dev->len = dev->bpl/segnb;
+  dev->dist = dev->bpl/segnb;
+  dev->segnb = segnb;
+  dev->line_count = 0;
+  dev->line_interp = 0;
+
+  DBG (DBG_io2, "%s: used_pixels     =%d\n", __func__, used_pixels);
+  DBG (DBG_io2, "%s: pixels          =%d\n", __func__, pixels);
+  DBG (DBG_io2, "%s: depth           =%d\n", __func__, depth);
+  DBG (DBG_io2, "%s: dev->bpl        =%lu\n", __func__, (unsigned long)dev->bpl);
+  DBG (DBG_io2, "%s: dev->len        =%lu\n", __func__, (unsigned long)dev->len);
+  DBG (DBG_io2, "%s: dev->dist       =%lu\n", __func__, (unsigned long)dev->dist);
+  DBG (DBG_io2, "%s: dev->line_interp=%lu\n", __func__, (unsigned long)dev->line_interp);
+
+  words_per_line *= channels;
+  dev->wpl = words_per_line;
+
+  /* allocate buffer for odd/even pixels handling */
+  if(dev->oe_buffer.buffer!=NULL)
+    {
+      sanei_genesys_buffer_free (&(dev->oe_buffer));
+    }
+  RIE (sanei_genesys_buffer_alloc (&(dev->oe_buffer), dev->wpl));
+
+  /* MAXWD is expressed in 2 words unit */
+  sanei_genesys_set_triple(reg,REG_MAXWD,(words_per_line));
+  DBG (DBG_io2, "%s: words_per_line used=%d\n", __func__, words_per_line);
+
+  sanei_genesys_set_triple(reg,REG_LPERIOD,exposure_time);
+  DBG (DBG_io2, "%s: exposure_time used=%d\n", __func__, exposure_time);
+
+  sanei_genesys_set_double(reg,REG_DUMMY,dev->sensor.dummy_pixel);
+
+  DBGCOMPLETED;
+  return SANE_STATUS_GOOD;
+}
+
+/** set up registers for an actual scan
+ *
+ * this function sets up the scanner to scan in normal or single line mode
+ */
+GENESYS_STATIC
+SANE_Status
+gl125_init_scan_regs (Genesys_Device * dev,
+                      Genesys_Register_Set * reg,
+              float xres,        /*dpi */
+              float yres,        /*dpi */
+              float startx,        /*optical_res, from dummy_pixel+1 */
+              float starty,        /*base_ydpi, from home! */
+              float pixels,
+              float lines,
+              unsigned int depth,
+              unsigned int channels,
+              __sane_unused__ int scan_method,
+                      int scan_mode,
+              int color_filter,
+                      unsigned int flags)
+{
+  int used_res;
+  int start, used_pixels;
+  int bytes_per_line;
+  int move;
+  unsigned int lincnt;
+  unsigned int oflags, mflags; /**> optical and motor flags */
+  int exposure_time;
+  int stagger;
+
+  int dummy = 0;
+  int slope_dpi = 0;
+  int scan_step_type = 1;
+  int max_shift;
+  size_t requested_buffer_size, read_buffer_size;
+
+  SANE_Bool half_ccd;                /* false: full CCD res is used, true, half max CCD res is used */
+  int optical_res;
+  SANE_Status status;
+
+  DBG (DBG_info,
+       "gl125_init_scan_regs settings:\n"
+       "Resolution    : %gDPI/%gDPI\n"
+       "Lines         : %g\n"
+       "PPL           : %g\n"
+       "Startpos      : %g/%g\n"
+       "Depth/Channels: %u/%u\n"
+       "Flags         : %x\n\n",
+       xres, yres, lines, pixels, startx, starty, depth, channels, flags);
+
+  half_ccd=compute_half_ccd(dev->model, xres);
+
+  /* optical_res */
+  optical_res = dev->sensor.optical_res;
+  if (half_ccd)
+    optical_res /= 2;
+  DBG (DBG_info, "%s: optical_res=%d\n", __func__, optical_res);
+
+  /* stagger */
+  if ((!half_ccd) && (dev->model->flags & GENESYS_FLAG_STAGGERED_LINE))
+    stagger = (4 * yres) / dev->motor.base_ydpi;
+  else
+    stagger = 0;
+  DBG (DBG_info, "gl125_init_scan_regs : stagger=%d lines\n", stagger);
+
+  /** @brief compute used resolution */
+  if (flags & SCAN_FLAG_USE_OPTICAL_RES)
+    {
+      used_res = optical_res;
+    }
+  else
+    {
+      /* resolution is choosen from a fixed list and can be used directly,
+       * unless we have ydpi higher than sensor's maximum one */
+      if(xres>optical_res)
+        used_res=optical_res;
+      else
+        used_res = xres;
+    }
+
+  /* compute scan parameters values */
+  /* pixels are allways given at full optical resolution */
+  /* use detected left margin and fixed value */
+  /* start */
+  /* add x coordinates */
+  start = startx;
+
+  if (stagger > 0)
+    start |= 1;
+
+  /* compute correct pixels number */
+  used_pixels = (pixels * optical_res) / xres;
+  DBG (DBG_info, "%s: used_pixels=%d\n", __func__, used_pixels);
+
+  /* round up pixels number if needed */
+  if (used_pixels * xres < pixels * optical_res)
+    used_pixels++;
+
+  /* we want even number of pixels here */
+  if(used_pixels & 1)
+    used_pixels++;
+
+  /* slope_dpi */
+  /* cis color scan is effectively a gray scan with 3 gray lines per color line and a FILTER of 0 */
+  if (dev->model->is_cis)
+    slope_dpi = yres * channels;
+  else
+    slope_dpi = yres;
+
+  /* scan_step_type */
+  if(flags & SCAN_FLAG_FEEDING)
+    {
+      scan_step_type=0;
+      exposure_time=MOVE_EXPOSURE;
+    }
+  else
+    {
+      exposure_time = gl125_compute_exposure (dev, used_res, half_ccd);
+      scan_step_type = sanei_genesys_compute_step_type(motors, dev->model->motor_type, exposure_time);
+    }
+
+  DBG (DBG_info, "gl125_init_scan_regs : exposure_time=%d pixels\n", exposure_time);
+  DBG (DBG_info, "gl125_init_scan_regs : scan_step_type=%d\n", scan_step_type);
+
+  /*** optical parameters ***/
+  /* in case of dynamic lineart, we use an internal 8 bit gray scan
+   * to generate 1 lineart data */
+  if ((flags & SCAN_FLAG_DYNAMIC_LINEART) && (scan_mode == SCAN_MODE_LINEART))
+    {
+      depth = 8;
+    }
+
+  /* we enable true gray for cis scanners only, and just when doing
+   * scan since color calibration is OK for this mode
+   */
+  oflags = 0;
+  if (flags & SCAN_FLAG_DISABLE_SHADING)
+    oflags |= OPTICAL_FLAG_DISABLE_SHADING;
+  if (flags & SCAN_FLAG_DISABLE_GAMMA)
+    oflags |= OPTICAL_FLAG_DISABLE_GAMMA;
+  if (flags & SCAN_FLAG_DISABLE_LAMP)
+    oflags |= OPTICAL_FLAG_DISABLE_LAMP;
+  if (flags & SCAN_FLAG_CALIBRATION)
+    oflags |= OPTICAL_FLAG_DISABLE_DOUBLE;
+
+  if (dev->model->is_cis && dev->settings.true_gray)
+    {
+      oflags |= OPTICAL_FLAG_ENABLE_LEDADD;
+    }
+
+  /* now _LOGICAL_ optical values used are known, setup registers */
+  status = gl125_init_optical_regs_scan (dev,
+                     reg,
+                     exposure_time,
+                     used_res,
+                     start,
+                     used_pixels,
+                     channels,
+                     depth,
+                     half_ccd,
+                                         color_filter,
+                                         oflags);
+  if (status != SANE_STATUS_GOOD)
+    return status;
+
+  /*** motor parameters ***/
+
+  /* max_shift */
+  max_shift=sanei_genesys_compute_max_shift(dev,channels,yres,flags);
+
+  /* lines to scan */
+  lincnt = lines + max_shift + stagger;
+
+  /* add tl_y to base movement */
+  move = starty;
+  DBG (DBG_info, "gl125_init_scan_regs: move=%d steps\n", move);
+
+  mflags=0;
+  if(flags & SCAN_FLAG_DISABLE_BUFFER_FULL_MOVE)
+    mflags|=MOTOR_FLAG_DISABLE_BUFFER_FULL_MOVE;
+  if(flags & SCAN_FLAG_FEEDING)
+    mflags|=MOTOR_FLAG_FEED;
+
+    status = gl125_init_motor_regs_scan (dev,
+                     reg,
+                     exposure_time,
+                     slope_dpi,
+                     scan_step_type,
+                     dev->model->is_cis ? lincnt * channels : lincnt,
+                     dummy,
+                     move,
+                     scan_mode,
+                     mflags);
+  if (status != SANE_STATUS_GOOD)
+    return status;
+
+  /*** prepares data reordering ***/
+
+  /* words_per_line */
+  bytes_per_line = (used_pixels * used_res) / optical_res;
+  bytes_per_line = (bytes_per_line * channels * depth) / 8;
+
+  /* since we don't have sheetfed scanners to handle,
+   * use huge read buffer */
+  /* TODO find the best size according to settings */
+  requested_buffer_size = 16 * bytes_per_line;
+
+  read_buffer_size =
+    2 * requested_buffer_size +
+    ((max_shift + stagger) * used_pixels * channels * depth) / 8;
+
+  RIE (sanei_genesys_buffer_free (&(dev->read_buffer)));
+  RIE (sanei_genesys_buffer_alloc (&(dev->read_buffer), read_buffer_size));
+
+  RIE (sanei_genesys_buffer_free (&(dev->lines_buffer)));
+  RIE (sanei_genesys_buffer_alloc (&(dev->lines_buffer), read_buffer_size));
+
+  RIE (sanei_genesys_buffer_free (&(dev->shrink_buffer)));
+  RIE (sanei_genesys_buffer_alloc (&(dev->shrink_buffer),
+                   requested_buffer_size));
+
+  RIE (sanei_genesys_buffer_free (&(dev->out_buffer)));
+  RIE (sanei_genesys_buffer_alloc (&(dev->out_buffer),
+                   (8 * dev->settings.pixels * channels *
+                    depth) / 8));
+
+
+  dev->read_bytes_left = bytes_per_line * lincnt;
+
+  DBG (DBG_info,
+       "gl125_init_scan_regs: physical bytes to read = %lu\n",
+       (u_long) dev->read_bytes_left);
+  dev->read_active = SANE_TRUE;
+
+
+  dev->current_setup.pixels = (used_pixels * used_res) / optical_res;
+  DBG (DBG_info, "%s: current_setup.pixels=%d\n", __func__, dev->current_setup.pixels);
+  dev->current_setup.lines = lincnt;
+  dev->current_setup.depth = depth;
+  dev->current_setup.channels = channels;
+  dev->current_setup.exposure_time = exposure_time;
+  dev->current_setup.xres = used_res;
+  dev->current_setup.yres = yres;
+  dev->current_setup.half_ccd = half_ccd;
+  dev->current_setup.stagger = stagger;
+  dev->current_setup.max_shift = max_shift + stagger;
+
+  dev->total_bytes_read = 0;
+  if (depth == 1)
+    dev->total_bytes_to_read =
+      ((dev->settings.pixels * dev->settings.lines) / 8 +
+       (((dev->settings.pixels * dev->settings.lines) % 8) ? 1 : 0)) *
+      channels;
+  else
+    dev->total_bytes_to_read =
+      dev->settings.pixels * dev->settings.lines * channels * (depth / 8);
+
+  DBG (DBG_info, "gl125_init_scan_regs: total bytes to send = %lu\n",
+       (u_long) dev->total_bytes_to_read);
+
+  DBGCOMPLETED;
+  return SANE_STATUS_GOOD;
+}
+
+static SANE_Status
+gl125_calculate_current_setup (Genesys_Device * dev)
+{
+  int channels;
+  int depth;
+  int start;
+
+  float xres;                        /*dpi */
+  float yres;                        /*dpi */
+  float startx;                        /*optical_res, from dummy_pixel+1 */
+  float pixels;
+  float lines;
+
+  int used_res;
+  int used_pixels;
+  unsigned int lincnt;
+  int exposure_time;
+  int stagger;
+  SANE_Bool half_ccd;
+
+  int max_shift, dpihw;
+  Sensor_Profile *sensor;
+
+  int optical_res;
+
+  DBG (DBG_info,
+       "gl125_calculate_current_setup settings:\n"
+       "Resolution: %ux%uDPI\n"
+       "Lines     : %u\n"
+       "PPL       : %u\n"
+       "Startpos  : %.3f/%.3f\n"
+       "Scan mode : %d\n\n",
+       dev->settings.xres,
+       dev->settings.yres, dev->settings.lines, dev->settings.pixels,
+       dev->settings.tl_x, dev->settings.tl_y, dev->settings.scan_mode);
+
+  /* channels */
+  if (dev->settings.scan_mode == 4)        /* single pass color */
+    channels = 3;
+  else
+    channels = 1;
+
+  /* depth */
+  depth = dev->settings.depth;
+  if (dev->settings.scan_mode == 0)
+    depth = 1;
+
+  /* start */
+  start = SANE_UNFIX (dev->model->x_offset);
+  start += dev->settings.tl_x;
+  start = (start * dev->sensor.optical_res) / MM_PER_INCH;
+
+
+  xres = dev->settings.xres;
+  yres = dev->settings.yres;
+  startx = start;
+  pixels = dev->settings.pixels;
+  lines = dev->settings.lines;
+
+  half_ccd=compute_half_ccd(dev->model, xres);
+
+  DBG (DBG_info,
+       "gl125_calculate_current_setup settings:\n"
+       "Resolution    : %gDPI/%gDPI\n"
+       "Lines         : %g\n"
+       "PPL           : %g\n"
+       "Startpos      : %g\n"
+       "Half ccd      : %d\n"
+       "Depth/Channels: %u/%u\n\n",
+       xres, yres, lines, pixels, startx, depth, half_ccd, channels);
+
+  /* optical_res */
+  optical_res = dev->sensor.optical_res;
+
+  if(xres<=optical_res)
+    used_res = xres;
+  else
+    used_res=optical_res;
+
+  /* compute scan parameters values */
+  /* pixels are allways given at half or full CCD optical resolution */
+  /* use detected left margin  and fixed value */
+
+  /* compute correct pixels number */
+  used_pixels = (pixels * optical_res) / xres;
+  DBG (DBG_info, "%s: used_pixels=%d\n", __func__, used_pixels);
+
+  /* exposure */
+  exposure_time = gl125_compute_exposure (dev, xres, half_ccd);
+  DBG (DBG_info, "%s : exposure_time=%d pixels\n", __func__, exposure_time);
+
+  /* max_shift */
+  max_shift=sanei_genesys_compute_max_shift(dev,channels,yres,0);
+
+  /* compute hw dpi for sensor */
+  dpihw=sanei_genesys_compute_dpihw(dev,used_res);
+
+  sensor=get_sensor_profile(dev->model->ccd_type, dpihw, half_ccd);
+  dev->segnb=sensor->reg98 & 0x0f;
+
+  /* stagger */
+  if ((!half_ccd) && (dev->model->flags & GENESYS_FLAG_STAGGERED_LINE))
+    stagger = (4 * yres) / dev->motor.base_ydpi;
+  else
+    stagger = 0;
+  DBG (DBG_info, "%s: stagger=%d lines\n", __func__, stagger);
+
+  /* lincnt */
+  lincnt = lines + max_shift + stagger;
+
+  dev->current_setup.pixels = (used_pixels * used_res) / optical_res;
+  DBG (DBG_info, "%s: current_setup.pixels=%d\n", __func__, dev->current_setup.pixels);
+  dev->current_setup.lines = lincnt;
+  dev->current_setup.depth = depth;
+  dev->current_setup.channels = channels;
+  dev->current_setup.exposure_time = exposure_time;
+  dev->current_setup.xres = used_res;
+  dev->current_setup.yres = yres;
+  dev->current_setup.half_ccd = half_ccd;
+  dev->current_setup.stagger = stagger;
+  dev->current_setup.max_shift = max_shift + stagger;
+
+  DBGCOMPLETED;
+  return SANE_STATUS_GOOD;
+}
+
+static void
+gl125_set_motor_power (Genesys_Register_Set * regs, SANE_Bool set)
+{
+
+  DBG (DBG_proc, "gl125_set_motor_power\n");
+
+  if (set)
+    {
+      sanei_genesys_set_reg_from_set (regs, REG02,
+                      sanei_genesys_read_reg_from_set (regs,
+                                       REG02)
+                      | REG02_MTRPWR);
+    }
+  else
+    {
+      sanei_genesys_set_reg_from_set (regs, REG02,
+                      sanei_genesys_read_reg_from_set (regs,
+                                       REG02)
+                      & ~REG02_MTRPWR);
+    }
+}
+
+static void
+gl125_set_lamp_power (Genesys_Device * dev,
+              Genesys_Register_Set * regs, SANE_Bool set)
+{
+  if (dev == NULL || regs==NULL)
+    return;
+
+  if (set)
+    {
+      sanei_genesys_set_reg_from_set (regs, 0x03,
+                      sanei_genesys_read_reg_from_set (regs,
+                                       0x03)
+                      | REG03_LAMPPWR);
+    }
+  else
+    {
+      sanei_genesys_set_reg_from_set (regs, 0x03,
+                      sanei_genesys_read_reg_from_set (regs,
+                                       0x03)
+                      & ~REG03_LAMPPWR);
+    }
+}
+
+/**
+ * for fast power saving methods only, like disabling certain amplifiers
+ * @param dev device to use
+ * @param enable true to set inot powersaving
+ * */
+static SANE_Status
+gl125_save_power (Genesys_Device * dev, SANE_Bool enable)
+{
+  DBG (DBG_proc, "gl125_save_power: enable = %d\n", enable);
+  if (dev == NULL)
+    return SANE_STATUS_INVAL;
+
+  DBGCOMPLETED;
+  return SANE_STATUS_GOOD;
+}
+
+static SANE_Status
+gl125_set_powersaving (Genesys_Device * dev, int delay /* in minutes */ )
+{
+  Genesys_Register_Set *r;
+
+  DBG (DBG_proc, "gl125_set_powersaving (delay = %d)\n", delay);
+
+  r = sanei_genesys_get_address (dev->reg, REG03);
+  r->value &= ~0xf0;
+  if(delay<15)
+    {
+      r->value |= delay;
+    }
+  else
+    {
+      r->value |= 0x0f;
+    }
+
+  DBGCOMPLETED;
+  return SANE_STATUS_GOOD;
+}
+
+#ifndef UNIT_TESTING
+static
+#endif
+  SANE_Status
+gl125_start_action (Genesys_Device * dev)
+{
+  return sanei_genesys_write_register (dev, 0x0f, 0x01);
+}
+
+#ifndef UNIT_TESTING
+static
+#endif
+SANE_Status
+gl125_stop_action (Genesys_Device * dev)
+{
+  SANE_Status status;
+  uint8_t val40, val;
+  unsigned int loop;
+
+  DBGSTART;
+
+  /* post scan gpio : without that HOMSNR is unreliable */
+  gl125_homsnr_gpio(dev);
+
+  status = sanei_genesys_get_status (dev, &val);
+  if (DBG_LEVEL >= DBG_io)
+    {
+      sanei_genesys_print_status (val);
+    }
+
+  status = sanei_genesys_read_register (dev, REG100, &val40);
+  if (status != SANE_STATUS_GOOD)
+    {
+      DBG (DBG_error,
+       "%s: failed to read reg100: %s\n", __func__,
+       sane_strstatus (status));
+      DBGCOMPLETED;
+      return status;
+    }
+
+  /* only stop action if needed */
+  if (!(val40 & REG100_DATAENB) && !(val40 & REG100_MOTMFLG))
+    {
+      DBG (DBG_info, "%s: already stopped\n", __func__);
+      DBGCOMPLETED;
+      return SANE_STATUS_GOOD;
+    }
+
+  /* ends scan */
+  val = sanei_genesys_read_reg_from_set (dev->reg, REG01);
+  val &= ~REG01_SCAN;
+  sanei_genesys_set_reg_from_set (dev->reg, REG01, val);
+  status = sanei_genesys_write_register (dev, REG01, val);
+  if (status != SANE_STATUS_GOOD)
+    {
+      DBG (DBG_error,
+       "%s: failed to write register 01: %s\n", __func__,
+       sane_strstatus (status));
+      return status;
+    }
+  usleep (100 * 1000);
+
+  loop = 10;
+  while (loop > 0)
+    {
+      status = sanei_genesys_get_status (dev, &val);
+      if (DBG_LEVEL >= DBG_io)
+    {
+      sanei_genesys_print_status (val);
+    }
+      status = sanei_genesys_read_register (dev, REG100, &val40);
+      if (status != SANE_STATUS_GOOD)
+    {
+      DBG (DBG_error,
+           "%s: failed to read home sensor: %s\n", __func__,
+           sane_strstatus (status));
+      DBGCOMPLETED;
+      return status;
+    }
+
+      /* if scanner is in command mode, we are done */
+      if (!(val40 & REG100_DATAENB) && !(val40 & REG100_MOTMFLG)
+      && !(val & MOTORENB))
+    {
+      DBGCOMPLETED;
+      return SANE_STATUS_GOOD;
+    }
+
+      usleep (100 * 1000);
+      loop--;
+    }
+
+  DBGCOMPLETED;
+  return SANE_STATUS_IO_ERROR;
+}
+
+
+/** @brief setup GPIOs for scan
+ * Setup GPIO values to drive motor (or light) needed for the
+ * target resolution
+ * @param *dev device to set up
+ * @param resolution dpi of the target scan
+ * @return SANE_STATUS_GOOD unless REG32 cannot be read
+ */
+static SANE_Status
+gl125_setup_scan_gpio(Genesys_Device *dev, int resolution)
+{
+SANE_Status status;
+uint8_t val;
+
+  DBGSTART;
+  RIE (sanei_genesys_read_register (dev, REG32, &val));
+
+  /* LiDE 110, 210 and 220 cases */
+  if(dev->model->gpo_type != GPO_CANONLIDE120)
+    {
+      if(resolution>=dev->motor.base_ydpi/2)
+    {
+      val &= 0xf7;
+    }
+      else if(resolution>=dev->motor.base_ydpi/4)
+    {
+      val &= 0xef;
+    }
+      else
+    {
+      val |= 0x10;
+    }
+    }
+  /* 120 : <=300 => 0x53 */
+  else
+    { /* base_ydpi is 4800 */
+      if(resolution<=300)
+    {
+      val &= 0xf7;
+    }
+      else if(resolution<=600)
+    {
+      val |= 0x08;
+    }
+      else if(resolution<=1200)
+    {
+      val &= 0xef;
+      val |= 0x08;
+    }
+      else
+    {
+      val &= 0xf7;
+    }
+    }
+  val |= 0x02;
+  RIE (sanei_genesys_write_register (dev, REG32, val));
+  DBGCOMPLETED;
+  return SANE_STATUS_GOOD;
+}
+
+/* Send the low-level scan command */
+/* todo : is this that useful ? */
+#ifndef UNIT_TESTING
+static
+#endif
+  SANE_Status
+gl125_begin_scan (Genesys_Device * dev, Genesys_Register_Set * reg,
+          SANE_Bool start_motor)
+{
+  SANE_Status status;
+  uint8_t val;
+
+  DBGSTART;
+  if (reg == NULL)
+    return SANE_STATUS_INVAL;
+
+  /* set up GPIO for scan */
+  RIE(gl125_setup_scan_gpio(dev,dev->settings.yres));
+
+  /* clear scan and feed count */
+  RIE (sanei_genesys_write_register (dev, REG0D, REG0D_CLRLNCNT | REG0D_CLRMCNT));
+
+  /* enable scan and motor */
+  RIE (sanei_genesys_read_register (dev, REG01, &val));
+  val |= REG01_SCAN;
+  RIE (sanei_genesys_write_register (dev, REG01, val));
+
+  if (start_motor)
+    {
+      RIE (sanei_genesys_write_register (dev, REG0F, 1));
+    }
+  else
+    {
+      RIE (sanei_genesys_write_register (dev, REG0F, 0));
+    }
+
+  DBGCOMPLETED;
+  return status;
+}
+
+
+/* Send the stop scan command */
+#ifndef UNIT_TESTING
+static
+#endif
+  SANE_Status
+gl125_end_scan (Genesys_Device * dev, Genesys_Register_Set * reg,
+        SANE_Bool check_stop)
+{
+  SANE_Status status;
+
+  DBG (DBG_proc, "gl125_end_scan (check_stop = %d)\n", check_stop);
+  if (reg == NULL)
+    return SANE_STATUS_INVAL;
+
+  if (dev->model->is_sheetfed == SANE_TRUE)
+    {
+      status = SANE_STATUS_GOOD;
+    }
+  else                                /* flat bed scanners */
+    {
+      status = gl125_stop_action (dev);
+      if (status != SANE_STATUS_GOOD)
+    {
+      DBG (DBG_error,
+           "gl125_end_scan: failed to stop: %s\n",
+           sane_strstatus (status));
+      return status;
+    }
+    }
+
+  DBGCOMPLETED;
+  return status;
+}
+
+
+/** rewind scan
+ * Move back by the same amount of distance than previous scan.
+ * @param dev device to rewind
+ * @returns SANE_STATUS_GOOD on success
+ */
+GENESYS_STATIC
+SANE_Status gl125_rewind(Genesys_Device * dev)
+{
+  SANE_Status status;
+  uint8_t byte;
+
+  DBGSTART;
+
+  /* set motor reverse */
+  RIE (sanei_genesys_read_register (dev, 0x02, &byte));
+  byte |= 0x04;
+  RIE (sanei_genesys_write_register(dev, 0x02, byte));
+
+  /* and start scan, then wait completion */
+  RIE (gl125_begin_scan (dev, dev->reg, SANE_TRUE));
+  do
+    {
+      usleep(100*1000);
+      RIE (sanei_genesys_read_register (dev, REG100, &byte));
+    }
+  while(byte & REG100_MOTMFLG);
+  RIE (gl125_end_scan (dev, dev->reg, SANE_TRUE));
+
+  /* restore direction */
+  RIE (sanei_genesys_read_register (dev, 0x02, &byte));
+  byte &= 0xfb;
+  RIE (sanei_genesys_write_register(dev, 0x02, byte));
+  DBGCOMPLETED;
+  return SANE_STATUS_GOOD;
+}
+
+
+/** Park head
+ * Moves the slider to the home (top) position slowly
+ * @param dev device to park
+ * @param wait_until_home true to make the function waiting for head
+ * to be home before returning, if fals returne immediately
+ * @returns SANE_STATUS_GOO on success */
+GENESYS_STATIC
+SANE_Status
+gl125_slow_back_home (Genesys_Device * dev, SANE_Bool wait_until_home)
+{
+  Genesys_Register_Set local_reg[GENESYS_GL125_MAX_REGS];
+  SANE_Status status;
+  Genesys_Register_Set *r;
+  uint8_t val;
+  float resolution;
+  int loop = 0;
+
+  DBG (DBG_proc, "gl125_slow_back_home (wait_until_home = %d)\n",
+       wait_until_home);
+
+  if(dev->usb_mode<0)
+    {
+      DBGCOMPLETED;
+      return SANE_STATUS_GOOD;
+    }
+
+  /* post scan gpio : without that HOMSNR is unreliable */
+  gl125_homsnr_gpio(dev);
+
+  /* first read gives HOME_SENSOR true */
+  status = sanei_genesys_get_status (dev, &val);
+  if (status != SANE_STATUS_GOOD)
+    {
+      DBG (DBG_error,
+       "gl125_slow_back_home: failed to read home sensor: %s\n",
+       sane_strstatus (status));
+      return status;
+    }
+  if (DBG_LEVEL >= DBG_io)
+    {
+      sanei_genesys_print_status (val);
+    }
+  usleep (100000);                /* sleep 100 ms */
+
+  /* second is reliable */
+  status = sanei_genesys_get_status (dev, &val);
+  if (status != SANE_STATUS_GOOD)
+    {
+      DBG (DBG_error,
+       "gl125_slow_back_home: failed to read home sensor: %s\n",
+       sane_strstatus (status));
+      return status;
+    }
+  if (DBG_LEVEL >= DBG_io)
+    {
+      sanei_genesys_print_status (val);
+    }
+
+  /* is sensor at home? */
+  if (val & HOMESNR)
+    {
+      DBG (DBG_info, "%s: already at home, completed\n", __func__);
+      dev->scanhead_position_in_steps = 0;
+      DBGCOMPLETED;
+      return SANE_STATUS_GOOD;
+    }
+
+  /* feed a little first */
+  if (strcmp (dev->model->name, "canon-lide-210") == 0)
+    {
+      status = gl125_feed (dev, 20, SANE_TRUE);
+      if (status != SANE_STATUS_GOOD)
+        {
+          DBG (DBG_error, "%s: failed to do initial feed: %s\n", __func__, sane_strstatus (status));
+          return status;
+        }
+    }
+
+  memcpy (local_reg, dev->reg, GENESYS_GL125_MAX_REGS * sizeof (Genesys_Register_Set));
+  resolution=sanei_genesys_get_lowest_dpi(dev);
+
+  status = gl125_init_scan_regs (dev,
+                                 local_reg,
+                                 resolution,
+                                 resolution,
+                                 100,
+                                 30000,
+                                 100,
+                                 100,
+                                 8,
+                                 1,
+                                 dev->settings.scan_method,
+                                 SCAN_MODE_GRAY,
+                                 0,
+                                 SCAN_FLAG_DISABLE_SHADING |
+                                 SCAN_FLAG_DISABLE_GAMMA |
+                                 SCAN_FLAG_IGNORE_LINE_DISTANCE);
+  if (status != SANE_STATUS_GOOD)
+    {
+      DBG (DBG_error,
+           "gl125_slow_back_home: failed to set up registers: %s\n",
+           sane_strstatus (status));
+      DBGCOMPLETED;
+      return status;
+    }
+
+  /* clear scan and feed count */
+  RIE (sanei_genesys_write_register (dev, REG0D, REG0D_CLRLNCNT | REG0D_CLRMCNT));
+
+  /* set up for reverse and no scan */
+  r = sanei_genesys_get_address (local_reg, REG02);
+  r->value |= REG02_MTRREV;
+
+  RIE (dev->model->cmd_set->bulk_write_register (dev, local_reg, GENESYS_GL125_MAX_REGS));
+
+  RIE(gl125_setup_scan_gpio(dev,resolution));
+
+  status = gl125_start_action (dev);
+  if (status != SANE_STATUS_GOOD)
+    {
+      DBG (DBG_error,
+       "gl125_slow_back_home: failed to start motor: %s\n",
+       sane_strstatus (status));
+      gl125_stop_action (dev);
+      /* restore original registers */
+      dev->model->cmd_set->bulk_write_register (dev, dev->reg, GENESYS_GL125_MAX_REGS);
+      return status;
+    }
+
+  /* post scan gpio : without that HOMSNR is unreliable */
+  gl125_homsnr_gpio(dev);
+
+  if (wait_until_home)
+    {
+
+      while (loop < 300)        /* do not wait longer then 30 seconds */
+    {
+      status = sanei_genesys_get_status (dev, &val);
+      if (status != SANE_STATUS_GOOD)
+        {
+          DBG (DBG_error,
+           "gl125_slow_back_home: failed to read home sensor: %s\n",
+           sane_strstatus (status));
+          return status;
+        }
+
+      if (val & HOMESNR)        /* home sensor */
+        {
+          DBG (DBG_info, "gl125_slow_back_home: reached home position\n");
+          DBGCOMPLETED;
+              dev->scanhead_position_in_steps = 0;
+          return SANE_STATUS_GOOD;
+        }
+      usleep (100000);        /* sleep 100 ms */
+      ++loop;
+    }
+
+      /* when we come here then the scanner needed too much time for this, so we better stop the motor */
+      gl125_stop_action (dev);
+      DBG (DBG_error,
+       "gl125_slow_back_home: timeout while waiting for scanhead to go home\n");
+      return SANE_STATUS_IO_ERROR;
+    }
+
+  DBG (DBG_info, "gl125_slow_back_home: scanhead is still moving\n");
+  DBGCOMPLETED;
+  return SANE_STATUS_GOOD;
+}
+
+/** @brief moves the slider to steps at motor base dpi
+ * @param dev device to work on
+ * @param steps number of steps to move
+ * @param reverse true is moving backward
+ * */
+#ifndef UNIT_TESTING
+static
+#endif
+SANE_Status
+gl125_feed (Genesys_Device * dev, unsigned int steps, int reverse)
+{
+  Genesys_Register_Set local_reg[GENESYS_GL125_MAX_REGS];
+  SANE_Status status;
+  Genesys_Register_Set *r;
+  float resolution;
+  uint8_t val;
+
+  DBGSTART;
+  DBG (DBG_io, "%s: steps=%d\n", __func__, steps);
+
+  /* prepare local registers */
+  memcpy (local_reg, dev->reg, GENESYS_GL125_MAX_REGS * sizeof (Genesys_Register_Set));
+
+  resolution=sanei_genesys_get_lowest_ydpi(dev);
+  status = gl125_init_scan_regs (dev,
+                                 local_reg,
+                                 resolution,
+                                 resolution,
+                                 0,
+                                 steps,
+                                 100,
+                                 3,
+                                 8,
+                                 3,
+                                 dev->settings.scan_method,
+                                 SCAN_MODE_COLOR,
+                                 dev->settings.color_filter,
+                                 SCAN_FLAG_DISABLE_SHADING |
+                                 SCAN_FLAG_DISABLE_GAMMA |
+                                 SCAN_FLAG_FEEDING |
+                                 SCAN_FLAG_DISABLE_BUFFER_FULL_MOVE |
+                                 SCAN_FLAG_IGNORE_LINE_DISTANCE);
+  if (status != SANE_STATUS_GOOD)
+    {
+      DBG (DBG_error, "%s: failed to set up registers: %s\n", __func__, sane_strstatus (status));
+      DBGCOMPLETED;
+      return status;
+    }
+
+  /* set exposure to zero */
+  sanei_genesys_set_triple(local_reg,REG_EXPR,0);
+  sanei_genesys_set_triple(local_reg,REG_EXPG,0);
+  sanei_genesys_set_triple(local_reg,REG_EXPB,0);
+
+  /* clear scan and feed count */
+  RIE (sanei_genesys_write_register (dev, REG0D, REG0D_CLRLNCNT));
+  RIE (sanei_genesys_write_register (dev, REG0D, REG0D_CLRMCNT));
+
+  /* set up for no scan */
+  r = sanei_genesys_get_address (local_reg, REG01);
+  r->value &= ~REG01_SCAN;
+
+  /* set up for reverse if needed */
+  if(reverse)
+    {
+      r = sanei_genesys_get_address (local_reg, REG02);
+      r->value |= REG02_MTRREV;
+    }
+
+  /* send registers */
+  RIE (dev->model->cmd_set->bulk_write_register (dev, local_reg, GENESYS_GL125_MAX_REGS));
+
+  status = gl125_start_action (dev);
+  if (status != SANE_STATUS_GOOD)
+    {
+      DBG (DBG_error, "%s: failed to start motor: %s\n", __func__, sane_strstatus (status));
+      gl125_stop_action (dev);
+
+      /* restore original registers */
+      dev->model->cmd_set->bulk_write_register (dev, dev->reg, GENESYS_GL125_MAX_REGS);
+      return status;
+    }
+
+  /* wait until feed count reaches the required value, but do not
+   * exceed 30s */
+  do
+    {
+          status = sanei_genesys_get_status (dev, &val);
+    }
+  while (status == SANE_STATUS_GOOD && !(val & FEEDFSH));
+
+  /* then stop scanning */
+  RIE(gl125_stop_action (dev));
+
+  DBGCOMPLETED;
+  return SANE_STATUS_GOOD;
+}
+
+
+/* Automatically set top-left edge of the scan area by scanning a 200x200 pixels
+   area at 600 dpi from very top of scanner */
+static SANE_Status
+gl125_search_start_position (Genesys_Device * dev)
+{
+  int size;
+  SANE_Status status;
+  uint8_t *data;
+  Genesys_Register_Set local_reg[GENESYS_GL125_MAX_REGS];
+  int steps;
+
+  int pixels = 600;
+  int dpi = 300;
+
+  DBGSTART;
+
+  memcpy (local_reg, dev->reg,
+      GENESYS_GL125_MAX_REGS * sizeof (Genesys_Register_Set));
+
+  /* sets for a 200 lines * 600 pixels */
+  /* normal scan with no shading */
+
+  status = gl125_init_scan_regs (dev,
+                                 local_reg,
+                                 dpi,
+                                 dpi,
+                                 0,
+                 0,        /*we should give a small offset here~60 steps */
+                 600,
+                                 dev->model->search_lines,
+                                 8,
+                                 1,
+                                 dev->settings.scan_method,
+                                 SCAN_MODE_GRAY,
+                 1,        /*green */
+                 SCAN_FLAG_DISABLE_SHADING |
+                 SCAN_FLAG_DISABLE_GAMMA |
+                 SCAN_FLAG_IGNORE_LINE_DISTANCE |
+                 SCAN_FLAG_DISABLE_BUFFER_FULL_MOVE);
+  if (status!=SANE_STATUS_GOOD)
+    {
+      DBG (DBG_error,
+       "%s: failed to init scan registers: %s\n", __func__,
+       sane_strstatus (status));
+      return status;
+    }
+
+  /* send to scanner */
+  status = dev->model->cmd_set->bulk_write_register (dev, local_reg, GENESYS_GL125_MAX_REGS);
+  if (status != SANE_STATUS_GOOD)
+    {
+      DBG (DBG_error,
+       "gl125_search_start_position: failed to bulk write registers: %s\n",
+       sane_strstatus (status));
+      return status;
+    }
+
+  size = pixels * dev->model->search_lines;
+
+  data = malloc (size);
+  if (!data)
+    {
+      DBG (DBG_error,
+       "gl125_search_start_position: failed to allocate memory\n");
+      return SANE_STATUS_NO_MEM;
+    }
+
+  status = gl125_begin_scan (dev, local_reg, SANE_TRUE);
+  if (status != SANE_STATUS_GOOD)
+    {
+      free (data);
+      DBG (DBG_error,
+       "gl125_search_start_position: failed to begin scan: %s\n",
+       sane_strstatus (status));
+      return status;
+    }
+
+  /* waits for valid data */
+  do
+    sanei_genesys_test_buffer_empty (dev, &steps);
+  while (steps);
+
+  /* now we're on target, we can read data */
+  status = sanei_genesys_read_data_from_scanner (dev, data, size);
+  if (status != SANE_STATUS_GOOD)
+    {
+      free (data);
+      DBG (DBG_error,
+       "gl125_search_start_position: failed to read data: %s\n",
+       sane_strstatus (status));
+      return status;
+    }
+
+  if (DBG_LEVEL >= DBG_data)
+    sanei_genesys_write_pnm_file ("search_position.pnm", data, 8, 1, pixels,
+                  dev->model->search_lines);
+
+  status = gl125_end_scan (dev, local_reg, SANE_TRUE);
+  if (status != SANE_STATUS_GOOD)
+    {
+      free (data);
+      DBG (DBG_error,
+       "gl125_search_start_position: failed to end scan: %s\n",
+       sane_strstatus (status));
+      return status;
+    }
+
+  /* update regs to copy ASIC internal state */
+  memcpy (dev->reg, local_reg,
+      GENESYS_GL125_MAX_REGS * sizeof (Genesys_Register_Set));
+
+  status =
+    sanei_genesys_search_reference_point (dev, data, 0, dpi, pixels,
+                      dev->model->search_lines);
+  if (status != SANE_STATUS_GOOD)
+    {
+      free (data);
+      DBG (DBG_error,
+       "gl125_search_start_position: failed to set search reference point: %s\n",
+       sane_strstatus (status));
+      return status;
+    }
+
+  free (data);
+  DBGCOMPLETED;
+  return SANE_STATUS_GOOD;
+}
+
+/*
+ * sets up register for coarse gain calibration
+ * todo: check it for scanners using it */
+static SANE_Status
+gl125_init_regs_for_coarse_calibration (Genesys_Device * dev)
+{
+  SANE_Status status;
+  uint8_t channels;
+  uint8_t cksel;
+
+  DBGSTART;
+  cksel = (dev->calib_reg[reg_0x18].value & REG18_CKSEL) + 1;        /* clock speed = 1..4 clocks */
+
+  /* set line size */
+  if (dev->settings.scan_mode == SCAN_MODE_COLOR)        /* single pass color */
+    channels = 3;
+  else
+    channels = 1;
+
+  status = gl125_init_scan_regs (dev,
+                 dev->calib_reg,
+                 dev->settings.xres,
+                 dev->settings.yres,
+                 0,
+                 0,
+                 dev->sensor.optical_res / cksel,
+                 20,
+                 16,
+                 channels,
+                                 dev->settings.scan_method,
+                                 dev->settings.scan_mode,
+                 dev->settings.color_filter,
+                 SCAN_FLAG_DISABLE_SHADING |
+                 SCAN_FLAG_DISABLE_GAMMA |
+                 SCAN_FLAG_SINGLE_LINE |
+                 SCAN_FLAG_FEEDING |
+                 SCAN_FLAG_IGNORE_LINE_DISTANCE);
+  if (status != SANE_STATUS_GOOD)
+    {
+      DBG (DBG_error,
+       "gl125_init_register_for_coarse_calibration: failed to setup scan: %s\n",
+       sane_strstatus (status));
+      return status;
+    }
+  gl125_set_motor_power (dev->calib_reg, SANE_FALSE);
+
+  DBG (DBG_info,
+       "gl125_init_register_for_coarse_calibration: optical sensor res: %d dpi, actual res: %d\n",
+       dev->sensor.optical_res / cksel, dev->settings.xres);
+
+  status = dev->model->cmd_set->bulk_write_register (dev, dev->calib_reg, GENESYS_GL125_MAX_REGS);
+  if (status != SANE_STATUS_GOOD)
+    {
+      DBG (DBG_error,
+       "gl125_init_register_for_coarse_calibration: failed to bulk write registers: %s\n",
+       sane_strstatus (status));
+      return status;
+    }
+
+  DBGCOMPLETED;
+  return SANE_STATUS_GOOD;
+}
+
+
+/* init registers for shading calibration */
+/* shading calibration is done at dpihw */
+static SANE_Status
+gl125_init_regs_for_shading (Genesys_Device * dev)
+{
+  SANE_Status status;
+  int move, resolution, dpihw, factor;
+
+  DBGSTART;
+
+  /* initial calibration reg values */
+  memcpy (dev->calib_reg, dev->reg, GENESYS_GL125_MAX_REGS * sizeof (Genesys_Register_Set));
+
+  dev->calib_channels = 3;
+  dev->calib_lines = dev->model->shading_lines;
+  dpihw=sanei_genesys_compute_dpihw(dev,dev->settings.xres);
+  if(dpihw>=2400)
+    {
+      dev->calib_lines *= 2;
+    }
+  resolution=dpihw;
+
+  /* if half CCD mode, use half resolution */
+  if(compute_half_ccd(dev->model, dev->settings.xres)==SANE_TRUE)
+    {
+      resolution /= 2;
+      dev->calib_lines /= 2;
+    }
+  dev->calib_resolution = resolution;
+  factor=dev->sensor.optical_res/resolution;
+  dev->calib_pixels = dev->sensor.sensor_pixels/factor;
+
+  /* distance to move to reach white target at high resolution */
+  move=0;
+  if(dev->settings.yres>=1200)
+    {
+      move = SANE_UNFIX (dev->model->y_offset_calib);
+      move = (move * (dev->motor.base_ydpi/4)) / MM_PER_INCH;
+    }
+  DBG (DBG_io, "%s: move=%d steps\n", __func__, move);
+
+  status = gl125_init_scan_regs (dev,
+                 dev->calib_reg,
+                 resolution,
+                 resolution,
+                 0,
+                 move,
+                 dev->calib_pixels,
+                 dev->calib_lines,
+                 16,
+                 dev->calib_channels,
+                                 dev->settings.scan_method,
+                                 SCAN_MODE_COLOR,
+                 0,
+                 SCAN_FLAG_DISABLE_SHADING |
+                 SCAN_FLAG_DISABLE_GAMMA |
+                 SCAN_FLAG_DISABLE_BUFFER_FULL_MOVE |
+                 SCAN_FLAG_IGNORE_LINE_DISTANCE);
+  gl125_set_motor_power (dev->calib_reg, SANE_FALSE);
+
+  if (status != SANE_STATUS_GOOD)
+    {
+      DBG (DBG_error, "%s: failed to setup scan: %s\n", __func__,
+       sane_strstatus (status));
+      return status;
+    }
+
+  dev->scanhead_position_in_steps += dev->calib_lines + move;
+
+  status = dev->model->cmd_set->bulk_write_register (dev, dev->calib_reg, GENESYS_GL125_MAX_REGS);
+  if (status != SANE_STATUS_GOOD)
+    {
+      DBG (DBG_error,
+       "%s: failed to bulk write registers: %s\n", __func__,
+       sane_strstatus (status));
+      return status;
+    }
+
+  DBGCOMPLETED;
+  return SANE_STATUS_GOOD;
+}
+
+/** @brief set up registers for the actual scan
+ */
+static SANE_Status
+gl125_init_regs_for_scan (Genesys_Device * dev)
+{
+  int channels;
+  int flags;
+  int depth;
+  float move;
+  int move_dpi;
+  float start;
+  uint8_t val40,val;
+
+  SANE_Status status;
+
+  DBG (DBG_info,
+       "gl125_init_regs_for_scan settings:\nResolution: %ux%uDPI\n"
+       "Lines     : %u\npixels    : %u\nStartpos  : %.3f/%.3f\nScan mode : %d\n\n",
+       dev->settings.xres,
+       dev->settings.yres,
+       dev->settings.lines,
+       dev->settings.pixels,
+       dev->settings.tl_x,
+       dev->settings.tl_y,
+       dev->settings.scan_mode);
+
+  /* wait for motor to stop first */
+  status = sanei_genesys_get_status (dev, &val);
+  if (status != SANE_STATUS_GOOD)
+   {
+     DBG (DBG_error, "%s: failed to read status: %s\n", __func__, sane_strstatus (status));
+     DBGCOMPLETED;
+     return status;
+   }
+  status = sanei_genesys_read_register (dev, REG100, &val40);
+  if (status != SANE_STATUS_GOOD)
+   {
+     DBG (DBG_error, "%s: failed to read reg100: %s\n", __func__, sane_strstatus (status));
+     DBGCOMPLETED;
+     return status;
+   }
+  if((val & MOTORENB) || (val40 & REG100_MOTMFLG))
+    {
+      do
+        {
+          usleep(10000);
+          status = sanei_genesys_get_status (dev, &val);
+          if (status != SANE_STATUS_GOOD)
+           {
+             DBG (DBG_error, "%s: failed to read status: %s\n", __func__, sane_strstatus (status));
+             DBGCOMPLETED;
+             return status;
+           }
+          status = sanei_genesys_read_register (dev, REG100, &val40);
+          if (status != SANE_STATUS_GOOD)
+           {
+             DBG (DBG_error, "%s: failed to read reg100: %s\n", __func__, sane_strstatus (status));
+             DBGCOMPLETED;
+             return status;
+           }
+        } while ((val & MOTORENB) || (val40 & REG100_MOTMFLG));
+        usleep(50000);
+    }
+
+  /* ensure head is parked in case of calibration */
+  RIE (gl125_slow_back_home (dev, SANE_TRUE));
+
+  /* channels */
+  if (dev->settings.scan_mode == SCAN_MODE_COLOR)
+    channels = 3;
+  else
+    channels = 1;
+
+  /* depth */
+  depth = dev->settings.depth;
+  if (dev->settings.scan_mode == SCAN_MODE_LINEART)
+    depth = 1;
+
+  /* y (motor) distance to move to reach scanned area */
+  move_dpi = dev->motor.base_ydpi/4;
+  move = SANE_UNFIX (dev->model->y_offset);
+  move += dev->settings.tl_y;
+  move = (move * move_dpi) / MM_PER_INCH;
+  DBG (DBG_info, "%s: move=%f steps\n", __func__, move);
+
+  if(channels*dev->settings.yres>=600 && move>700)
+    {
+      status = gl125_feed (dev, move-500, SANE_FALSE);
+      if (status != SANE_STATUS_GOOD)
+        {
+          DBG (DBG_error, "%s: failed to move to scan area\n",__func__);
+          return status;
+        }
+      move=500;
+    }
+  DBG (DBG_info, "gl125_init_regs_for_scan: move=%f steps\n", move);
+
+  /* start */
+  start = SANE_UNFIX (dev->model->x_offset);
+  start += dev->settings.tl_x;
+  if(compute_half_ccd(dev->model, dev->settings.xres)==SANE_TRUE)
+    {
+      start /=2;
+    }
+  start = (start * dev->sensor.optical_res) / MM_PER_INCH;
+
+  flags = 0;
+
+  /* enable emulated lineart from gray data */
+  if(dev->settings.scan_mode == SCAN_MODE_LINEART
+     && dev->settings.dynamic_lineart)
+    {
+      flags |= SCAN_FLAG_DYNAMIC_LINEART;
+    }
+
+  status = gl125_init_scan_regs (dev,
+                 dev->reg,
+                 dev->settings.xres,
+                 dev->settings.yres,
+                 start,
+                 move,
+                 dev->settings.pixels,
+                 dev->settings.lines,
+                 depth,
+                 channels,
+                                 dev->settings.scan_method,
+                                 dev->settings.scan_mode,
+                                 dev->settings.color_filter,
+                                 flags);
+
+  if (status != SANE_STATUS_GOOD)
+    return status;
+
+  DBGCOMPLETED;
+  return SANE_STATUS_GOOD;
+}
+
+/**
+ * Send shading calibration data. The buffer is considered to always hold values
+ * for all the channels.
+ */
+#ifndef UNIT_TESTING
+static
+#endif
+SANE_Status
+gl125_send_shading_data (Genesys_Device * dev, uint8_t * data, int size)
+{
+  SANE_Status status = SANE_STATUS_GOOD;
+  uint32_t addr, length, strpixel ,endpixel, x, factor, segcnt, pixels, i;
+  uint32_t lines, channels;
+  uint16_t dpiset,dpihw;
+  uint8_t val,*buffer,*ptr,*src;
+
+  DBGSTART;
+  DBG( DBG_io2, "%s: writing %d bytes of shading data\n",__func__,size);
+
+  /* logical size of a color as seen by generic code of the frontend */
+  length = (uint32_t) (size / 3);
+  sanei_genesys_get_triple(dev->reg,REG_STRPIXEL,&strpixel);
+  sanei_genesys_get_triple(dev->reg,REG_ENDPIXEL,&endpixel);
+  sanei_genesys_get_triple(dev->reg,REG_SEGCNT,&segcnt);
+  if(endpixel==0)
+    {
+      endpixel=segcnt;
+    }
+  DBG( DBG_io2, "%s: STRPIXEL=%d, ENDPIXEL=%d, PIXELS=%d, SEGCNT=%d\n",__func__,strpixel,endpixel,endpixel-strpixel,segcnt);
+
+  /* compute deletion factor */
+  sanei_genesys_get_double(dev->reg,REG_DPISET,&dpiset);
+  dpihw=sanei_genesys_compute_dpihw(dev,dpiset);
+  factor=dpihw/dpiset;
+  DBG( DBG_io2, "%s: factor=%d\n",__func__,factor);
+
+  /* binary data logging */
+  if(DBG_LEVEL>=DBG_data)
+    {
+      dev->binary=fopen("binary.pnm","wb");
+      sanei_genesys_get_triple(dev->reg, REG_LINCNT, &lines);
+      channels=dev->current_setup.channels;
+      if(dev->binary!=NULL)
+        {
+          fprintf(dev->binary,"P5\n%d %d\n%d\n",(endpixel-strpixel)/factor*channels*dev->segnb,lines/channels,255);
+        }
+    }
+
+  /* turn pixel value into bytes 2x16 bits words */
+  strpixel*=2*2; /* 2 words of 2 bytes */
+  endpixel*=2*2;
+  segcnt*=2*2;
+  pixels=endpixel-strpixel;
+
+  DBG( DBG_io2, "%s: using chunks of %d bytes (%d shading data pixels)\n",__func__,length, length/4);
+  buffer=(uint8_t *)malloc(pixels*dev->segnb);
+  memset(buffer,0,pixels*dev->segnb);
+
+  /* write actual red data */
+  for(i=0;i<3;i++)
+    {
+      /* copy data to work buffer and process it */
+          /* coefficent destination */
+      ptr=buffer;
+
+      /* iterate on both sensor segment */
+      for(x=0;x<pixels;x+=4*factor)
+        {
+          /* coefficient source */
+          src=data+x+strpixel+i*length;
+
+          /* iterate over all the segments */
+          switch(dev->segnb)
+            {
+            case 1:
+              ptr[0+pixels*0]=src[0+segcnt*0];
+              ptr[1+pixels*0]=src[1+segcnt*0];
+              ptr[2+pixels*0]=src[2+segcnt*0];
+              ptr[3+pixels*0]=src[3+segcnt*0];
+              break;
+            case 2:
+              ptr[0+pixels*0]=src[0+segcnt*0];
+              ptr[1+pixels*0]=src[1+segcnt*0];
+              ptr[2+pixels*0]=src[2+segcnt*0];
+              ptr[3+pixels*0]=src[3+segcnt*0];
+              ptr[0+pixels*1]=src[0+segcnt*1];
+              ptr[1+pixels*1]=src[1+segcnt*1];
+              ptr[2+pixels*1]=src[2+segcnt*1];
+              ptr[3+pixels*1]=src[3+segcnt*1];
+              break;
+            case 4:
+              ptr[0+pixels*0]=src[0+segcnt*0];
+              ptr[1+pixels*0]=src[1+segcnt*0];
+              ptr[2+pixels*0]=src[2+segcnt*0];
+              ptr[3+pixels*0]=src[3+segcnt*0];
+              ptr[0+pixels*1]=src[0+segcnt*2];
+              ptr[1+pixels*1]=src[1+segcnt*2];
+              ptr[2+pixels*1]=src[2+segcnt*2];
+              ptr[3+pixels*1]=src[3+segcnt*2];
+              ptr[0+pixels*2]=src[0+segcnt*1];
+              ptr[1+pixels*2]=src[1+segcnt*1];
+              ptr[2+pixels*2]=src[2+segcnt*1];
+              ptr[3+pixels*2]=src[3+segcnt*1];
+              ptr[0+pixels*3]=src[0+segcnt*3];
+              ptr[1+pixels*3]=src[1+segcnt*3];
+              ptr[2+pixels*3]=src[2+segcnt*3];
+              ptr[3+pixels*3]=src[3+segcnt*3];
+              break;
+            }
+
+          /* next shading coefficient */
+          ptr+=4;
+        }
+      RIE (sanei_genesys_read_register (dev, 0xd0+i, &val));
+      addr = val * 8192 + 0x10000000;
+      status = sanei_genesys_write_ahb (dev->dn, dev->usb_mode, addr, pixels*dev->segnb, buffer);
+      if (status != SANE_STATUS_GOOD)
+        {
+          DBG (DBG_error, "gl125_send_shading_data; write to AHB failed (%s)\n",
+               sane_strstatus (status));
+          return status;
+        }
+    }
+
+  free(buffer);
+  DBGCOMPLETED;
+
+  return status;
+}
+
+
+/** @brief move to calibration area
+ * This functions moves scanning head to calibration area
+ * by doing a 600 dpi scan
+ * @param dev scanner device
+ * @return SANE_STATUS_GOOD on success, else the error code
+ */
+static SANE_Status
+move_to_calibration_area (Genesys_Device * dev)
+{
+  int pixels;
+  int size;
+  uint8_t *line;
+  SANE_Status status = SANE_STATUS_GOOD;
+
+  DBGSTART;
+
+  pixels = (dev->sensor.sensor_pixels*600)/dev->sensor.optical_res;
+
+  /* initial calibration reg values */
+  memcpy (dev->calib_reg, dev->reg, GENESYS_GL125_MAX_REGS * sizeof (Genesys_Register_Set));
+
+  /* set up for the calibration scan */
+  status = gl125_init_scan_regs (dev,
+                 dev->calib_reg,
+                 600,
+                 600,
+                 0,
+                 0,
+                 pixels,
+                                 1,
+                                 8,
+                                 3,
+                                 dev->settings.scan_method,
+                                 SCAN_MODE_COLOR,
+                 dev->settings.color_filter,
+                 SCAN_FLAG_DISABLE_SHADING |
+                 SCAN_FLAG_DISABLE_GAMMA |
+                 SCAN_FLAG_SINGLE_LINE |
+                 SCAN_FLAG_IGNORE_LINE_DISTANCE);
+  if (status != SANE_STATUS_GOOD)
+    {
+      DBG (DBG_error, "%s: failed to setup scan: %s\n", __func__, sane_strstatus (status));
+      return status;
+    }
+
+  size = pixels * 3;
+  line = malloc (size);
+  if (!line)
+    return SANE_STATUS_NO_MEM;
+
+  /* write registers and scan data */
+  RIEF (dev->model->cmd_set->bulk_write_register (dev, dev->calib_reg, GENESYS_GL125_MAX_REGS), line);
+
+  DBG (DBG_info, "%s: starting line reading\n", __func__);
+  RIEF (gl125_begin_scan (dev, dev->calib_reg, SANE_TRUE), line);
+  RIEF (sanei_genesys_read_data_from_scanner (dev, line, size), line);
+
+  /* stop scanning */
+  RIE (gl125_stop_action (dev));
+
+  if (DBG_LEVEL >= DBG_data)
+    {
+      sanei_genesys_write_pnm_file ("movetocalarea.pnm", line, 8, 3, pixels, 1);
+    }
+
+  /* cleanup before return */
+  free (line);
+
+  DBGCOMPLETED;
+  return status;
+}
+
+/* this function does the led calibration by scanning one line of the calibration
+   area below scanner's top on white strip.
+
+-needs working coarse/gain
+*/
+static SANE_Status
+gl125_led_calibration (Genesys_Device * dev)
+{
+  int num_pixels;
+  int total_size;
+  int resolution;
+  int dpihw;
+  uint8_t *line;
+  int i, j;
+  SANE_Status status = SANE_STATUS_GOOD;
+  int val;
+  int channels, depth;
+  int avg[3];
+  int turn;
+  char fn[20];
+  uint16_t exp[3],target;
+  Sensor_Profile *sensor;
+  SANE_Bool acceptable;
+  SANE_Bool half_ccd;
+
+  DBGSTART;
+
+  /* move to calibration area */
+  move_to_calibration_area(dev);
+
+  /* offset calibration is always done in 16 bit depth color mode */
+  channels = 3;
+  depth=16;
+  dpihw=sanei_genesys_compute_dpihw(dev, dev->settings.xres);
+  half_ccd=compute_half_ccd(dev->model, dev->settings.xres);
+  if(half_ccd==SANE_TRUE)
+    {
+      resolution = dpihw/2;
+    }
+  else
+    {
+      resolution = dpihw;
+    }
+  sensor=get_sensor_profile(dev->model->ccd_type, dpihw, half_ccd);
+  num_pixels = (dev->sensor.sensor_pixels*resolution)/dev->sensor.optical_res;
+
+  /* initial calibration reg values */
+  memcpy (dev->calib_reg, dev->reg, GENESYS_GL125_MAX_REGS * sizeof (Genesys_Register_Set));
+
+  /* set up for the calibration scan */
+  status = gl125_init_scan_regs (dev,
+                 dev->calib_reg,
+                 resolution,
+                 resolution,
+                 0,
+                 0,
+                 num_pixels,
+                                 1,
+                                 depth,
+                                 channels,
+                                 dev->settings.scan_method,
+                                 SCAN_MODE_COLOR,
+                 dev->settings.color_filter,
+                 SCAN_FLAG_DISABLE_SHADING |
+                 SCAN_FLAG_DISABLE_GAMMA |
+                 SCAN_FLAG_SINGLE_LINE |
+                 SCAN_FLAG_IGNORE_LINE_DISTANCE);
+  if (status != SANE_STATUS_GOOD)
+    {
+      DBG (DBG_error, "%s: failed to setup scan: %s\n", __func__, sane_strstatus (status));
+      return status;
+    }
+
+  total_size = num_pixels * channels * (depth/8) * 1;        /* colors * bytes_per_color * scan lines */
+  line = malloc (total_size);
+  if (!line)
+    return SANE_STATUS_NO_MEM;
+
+  /* initial loop values and boundaries */
+  exp[0]=sensor->expr;
+  exp[1]=sensor->expg;
+  exp[2]=sensor->expb;
+  target=dev->sensor.gain_white_ref*256;
+
+  turn = 0;
+
+  /* no move during led calibration */
+  gl125_set_motor_power (dev->calib_reg, SANE_FALSE);
+  do
+    {
+      /* set up exposure */
+      sanei_genesys_set_triple(dev->calib_reg,REG_EXPR,exp[0]);
+      sanei_genesys_set_triple(dev->calib_reg,REG_EXPG,exp[1]);
+      sanei_genesys_set_triple(dev->calib_reg,REG_EXPB,exp[2]);
+
+      /* write registers and scan data */
+      RIEF (dev->model->cmd_set->bulk_write_register (dev, dev->calib_reg, GENESYS_GL125_MAX_REGS), line);
+
+      DBG (DBG_info, "gl125_led_calibration: starting line reading\n");
+      RIEF (gl125_begin_scan (dev, dev->calib_reg, SANE_TRUE), line);
+      RIEF (sanei_genesys_read_data_from_scanner (dev, line, total_size), line);
+
+      /* stop scanning */
+      RIEF (gl125_stop_action (dev), line);
+
+      if (DBG_LEVEL >= DBG_data)
+    {
+      snprintf (fn, 20, "led_%02d.pnm", turn);
+      sanei_genesys_write_pnm_file (fn, line, depth, channels, num_pixels, 1);
+    }
+
+      /* compute average */
+      for (j = 0; j < channels; j++)
+    {
+      avg[j] = 0;
+      for (i = 0; i < num_pixels; i++)
+        {
+          if (dev->model->is_cis)
+        val =
+          line[i * 2 + j * 2 * num_pixels + 1] * 256 +
+          line[i * 2 + j * 2 * num_pixels];
+          else
+        val =
+          line[i * 2 * channels + 2 * j + 1] * 256 +
+          line[i * 2 * channels + 2 * j];
+          avg[j] += val;
+        }
+
+      avg[j] /= num_pixels;
+    }
+
+      DBG (DBG_info, "gl125_led_calibration: average: %d,%d,%d\n", avg[0], avg[1], avg[2]);
+
+      /* check if exposure gives average within the boundaries */
+      acceptable = SANE_TRUE;
+      for(i=0;i<3;i++)
+        {
+          /* we accept +- 2% delta from target */
+          if(abs(avg[i]-target)>target/50)
+            {
+              exp[i]=(exp[i]*target)/avg[i];
+              acceptable = SANE_FALSE;
+            }
+        }
+
+      turn++;
+    }
+  while (!acceptable && turn < 100);
+
+  DBG (DBG_info, "gl125_led_calibration: acceptable exposure: %d,%d,%d\n", exp[0], exp[1], exp[2]);
+
+  /* set these values as final ones for scan */
+  sanei_genesys_set_triple(dev->reg,REG_EXPR,exp[0]);
+  sanei_genesys_set_triple(dev->reg,REG_EXPG,exp[1]);
+  sanei_genesys_set_triple(dev->reg,REG_EXPB,exp[2]);
+
+  /* store in this struct since it is the one used by cache calibration */
+  dev->sensor.regs_0x10_0x1d[0] = (exp[0] >> 8) & 0xff;
+  dev->sensor.regs_0x10_0x1d[1] = exp[0] & 0xff;
+  dev->sensor.regs_0x10_0x1d[2] = (exp[1] >> 8) & 0xff;
+  dev->sensor.regs_0x10_0x1d[3] = exp[1] & 0xff;
+  dev->sensor.regs_0x10_0x1d[4] = (exp[2] >> 8) & 0xff;
+  dev->sensor.regs_0x10_0x1d[5] = exp[2] & 0xff;
+
+  /* cleanup before return */
+  free (line);
+
+  DBGCOMPLETED;
+  return status;
+}
+
+/**
+ * average dark pixels of a 8 bits scan
+ */
+static int
+dark_average (uint8_t * data, unsigned int pixels, unsigned int lines,
+          unsigned int channels, unsigned int black)
+{
+  unsigned int i, j, k, average, count;
+  unsigned int avg[3];
+  uint8_t val;
+
+  /* computes average value on black margin */
+  for (k = 0; k < channels; k++)
+    {
+      avg[k] = 0;
+      count = 0;
+      for (i = 0; i < lines; i++)
+    {
+      for (j = 0; j < black; j++)
+        {
+          val = data[i * channels * pixels + j + k];
+          avg[k] += val;
+          count++;
+        }
+    }
+      if (count)
+    avg[k] /= count;
+      DBG (DBG_info, "dark_average: avg[%d] = %d\n", k, avg[k]);
+    }
+  average = 0;
+  for (i = 0; i < channels; i++)
+    average += avg[i];
+  average /= channels;
+  DBG (DBG_info, "dark_average: average = %d\n", average);
+  return average;
+}
+
+
+static SANE_Status
+gl125_offset_calibration (Genesys_Device * dev)
+{
+  SANE_Status status = SANE_STATUS_GOOD;
+  uint8_t *first_line, *second_line, reg0a;
+  unsigned int channels, bpp;
+  char title[32];
+  int pass = 0, avg, total_size;
+  int topavg, bottomavg, resolution, lines;
+  int top, bottom, black_pixels, pixels;
+
+  DBGSTART;
+
+  /* no gain nor offset for TI AFE */
+  RIE (sanei_genesys_read_register (dev, REG0A, &reg0a));
+  if(((reg0a & REG0A_SIFSEL)>>REG0AS_SIFSEL)==3)
+    {
+      DBGCOMPLETED;
+      return status;
+    }
+
+  /* offset calibration is always done in color mode */
+  channels = 3;
+  resolution=dev->sensor.optical_res;
+  dev->calib_pixels = dev->sensor.sensor_pixels;
+  lines=1;
+  bpp=8;
+  pixels= (dev->sensor.sensor_pixels*resolution) / dev->sensor.optical_res;
+  black_pixels = (dev->sensor.black_pixels * resolution) / dev->sensor.optical_res;
+  DBG (DBG_io2, "gl125_offset_calibration: black_pixels=%d\n", black_pixels);
+
+  status = gl125_init_scan_regs (dev,
+                 dev->calib_reg,
+                 resolution,
+                 resolution,
+                 0,
+                 0,
+                 pixels,
+                 lines,
+                 bpp,
+                 channels,
+                                 dev->settings.scan_method,
+                                 SCAN_MODE_COLOR,
+                 dev->settings.color_filter,
+                 SCAN_FLAG_DISABLE_SHADING |
+                 SCAN_FLAG_DISABLE_GAMMA |
+                 SCAN_FLAG_SINGLE_LINE |
+                 SCAN_FLAG_IGNORE_LINE_DISTANCE);
+  if (status != SANE_STATUS_GOOD)
+    {
+      DBG (DBG_error,
+       "gl125_offset_calibration: failed to setup scan: %s\n",
+       sane_strstatus (status));
+      return status;
+    }
+  gl125_set_motor_power (dev->calib_reg, SANE_FALSE);
+
+  /* allocate memory for scans */
+  total_size = pixels * channels * lines * (bpp/8);        /* colors * bytes_per_color * scan lines */
+
+  first_line = malloc (total_size);
+  if (!first_line)
+    return SANE_STATUS_NO_MEM;
+
+  second_line = malloc (total_size);
+  if (!second_line)
+    {
+      free (first_line);
+      return SANE_STATUS_NO_MEM;
+    }
+
+  /* init gain */
+  dev->frontend.gain[0] = 0;
+  dev->frontend.gain[1] = 0;
+  dev->frontend.gain[2] = 0;
+
+  /* scan with no move */
+  bottom = 10;
+  dev->frontend.offset[0] = bottom;
+  dev->frontend.offset[1] = bottom;
+  dev->frontend.offset[2] = bottom;
+
+  RIEF2 (gl125_set_fe(dev, AFE_SET), first_line, second_line);
+  RIEF2 (dev->model->cmd_set->bulk_write_register (dev, dev->calib_reg, GENESYS_GL125_MAX_REGS), first_line, second_line);
+  DBG (DBG_info, "gl125_offset_calibration: starting first line reading\n");
+  RIEF2 (gl125_begin_scan (dev, dev->calib_reg, SANE_TRUE), first_line, second_line);
+  RIEF2 (sanei_genesys_read_data_from_scanner (dev, first_line, total_size), first_line, second_line);
+  if (DBG_LEVEL >= DBG_data)
+   {
+      snprintf(title,20,"offset%03d.pnm",bottom);
+      sanei_genesys_write_pnm_file (title, first_line, bpp, channels, pixels, lines);
+   }
+
+  bottomavg = dark_average (first_line, pixels, lines, channels, black_pixels);
+  DBG (DBG_io2, "gl125_offset_calibration: bottom avg=%d\n", bottomavg);
+
+  /* now top value */
+  top = 255;
+  dev->frontend.offset[0] = top;
+  dev->frontend.offset[1] = top;
+  dev->frontend.offset[2] = top;
+  RIEF2 (gl125_set_fe(dev, AFE_SET), first_line, second_line);
+  RIEF2 (dev->model->cmd_set->bulk_write_register (dev, dev->calib_reg, GENESYS_GL125_MAX_REGS), first_line, second_line);
+  DBG (DBG_info, "gl125_offset_calibration: starting second line reading\n");
+  RIEF2 (gl125_begin_scan (dev, dev->calib_reg, SANE_TRUE), first_line, second_line);
+  RIEF2 (sanei_genesys_read_data_from_scanner (dev, second_line, total_size), first_line, second_line);
+
+  topavg = dark_average (second_line, pixels, lines, channels, black_pixels);
+  DBG (DBG_io2, "gl125_offset_calibration: top avg=%d\n", topavg);
+
+  /* loop until acceptable level */
+  while ((pass < 32) && (top - bottom > 1))
+    {
+      pass++;
+
+      /* settings for new scan */
+      dev->frontend.offset[0] = (top + bottom) / 2;
+      dev->frontend.offset[1] = (top + bottom) / 2;
+      dev->frontend.offset[2] = (top + bottom) / 2;
+
+      /* scan with no move */
+      RIEF2 (gl125_set_fe(dev, AFE_SET), first_line, second_line);
+      RIEF2 (dev->model->cmd_set->bulk_write_register (dev, dev->calib_reg, GENESYS_GL125_MAX_REGS), first_line, second_line);
+      DBG (DBG_info, "gl125_offset_calibration: starting second line reading\n");
+      RIEF2 (gl125_begin_scan (dev, dev->calib_reg, SANE_TRUE), first_line, second_line);
+      RIEF2 (sanei_genesys_read_data_from_scanner (dev, second_line, total_size), first_line, second_line);
+
+      if (DBG_LEVEL >= DBG_data)
+    {
+      sprintf (title, "offset%03d.pnm", dev->frontend.offset[1]);
+      sanei_genesys_write_pnm_file (title, second_line, bpp, channels, pixels, lines);
+    }
+
+      avg = dark_average (second_line, pixels, lines, channels, black_pixels);
+      DBG (DBG_info, "gl125_offset_calibration: avg=%d offset=%d\n", avg,
+       dev->frontend.offset[1]);
+
+      /* compute new boundaries */
+      if (topavg == avg)
+    {
+      topavg = avg;
+      top = dev->frontend.offset[1];
+    }
+      else
+    {
+      bottomavg = avg;
+      bottom = dev->frontend.offset[1];
+    }
+    }
+  DBG (DBG_info, "gl125_offset_calibration: offset=(%d,%d,%d)\n", dev->frontend.offset[0], dev->frontend.offset[1], dev->frontend.offset[2]);
+
+  /* cleanup before return */
+  free (first_line);
+  free (second_line);
+
+  DBGCOMPLETED;
+  return SANE_STATUS_GOOD;
+}
+
+
+/* alternative coarse gain calibration
+   this on uses the settings from offset_calibration and
+   uses only one scanline
+ */
+/*
+  with offset and coarse calibration we only want to get our input range into
+  a reasonable shape. the fine calibration of the upper and lower bounds will
+  be done with shading.
+ */
+static SANE_Status
+gl125_coarse_gain_calibration (Genesys_Device * dev, int dpi)
+{
+  int pixels;
+  int total_size;
+  uint8_t *line, reg0a;
+  int i, j, channels;
+  SANE_Status status = SANE_STATUS_GOOD;
+  int max[3];
+  float gain[3],coeff;
+  int val, code, lines;
+  int resolution;
+  int bpp;
+
+  DBG (DBG_proc, "gl125_coarse_gain_calibration: dpi = %d\n", dpi);
+
+  /* no gain nor offset for TI AFE */
+  RIE (sanei_genesys_read_register (dev, REG0A, &reg0a));
+  if(((reg0a & REG0A_SIFSEL)>>REG0AS_SIFSEL)==3)
+    {
+      DBGCOMPLETED;
+      return status;
+    }
+
+  /* coarse gain calibration is always done in color mode */
+  channels = 3;
+
+  /* follow CKSEL */
+  if(dev->settings.xres<dev->sensor.optical_res)
+    {
+      coeff=0.9;
+      /*resolution=dev->sensor.optical_res/2;*/
+      resolution=dev->sensor.optical_res;
+    }
+  else
+    {
+      resolution=dev->sensor.optical_res;
+      coeff=1.0;
+    }
+  lines=10;
+  bpp=8;
+  pixels = (dev->sensor.sensor_pixels * resolution) / dev->sensor.optical_res;
+
+  status = gl125_init_scan_regs (dev,
+                 dev->calib_reg,
+                 resolution,
+                 resolution,
+                 0,
+                 0,
+                 pixels,
+                                 lines,
+                                 bpp,
+                                 channels,
+                                 dev->settings.scan_method,
+                                 SCAN_MODE_COLOR,
+                 dev->settings.color_filter,
+                 SCAN_FLAG_DISABLE_SHADING |
+                 SCAN_FLAG_DISABLE_GAMMA |
+                 SCAN_FLAG_SINGLE_LINE |
+                 SCAN_FLAG_IGNORE_LINE_DISTANCE);
+  gl125_set_motor_power (dev->calib_reg, SANE_FALSE);
+
+  if (status != SANE_STATUS_GOOD)
+    {
+      DBG (DBG_error,
+       "gl125_coarse_calibration: failed to setup scan: %s\n",
+       sane_strstatus (status));
+      return status;
+    }
+
+  RIE (dev->model->cmd_set->bulk_write_register
+       (dev, dev->calib_reg, GENESYS_GL125_MAX_REGS));
+
+  total_size = pixels * channels * (16/bpp) * lines;
+
+  line = malloc (total_size);
+  if (!line)
+    return SANE_STATUS_NO_MEM;
+
+  RIEF (gl125_set_fe(dev, AFE_SET), line);
+  RIEF (gl125_begin_scan (dev, dev->calib_reg, SANE_TRUE), line);
+  RIEF (sanei_genesys_read_data_from_scanner (dev, line, total_size), line);
+
+  if (DBG_LEVEL >= DBG_data)
+    sanei_genesys_write_pnm_file ("coarse.pnm", line, bpp, channels, pixels, lines);
+
+  /* average value on each channel */
+  for (j = 0; j < channels; j++)
+    {
+      max[j] = 0;
+      for (i = pixels/4; i < (pixels*3/4); i++)
+    {
+          if(bpp==16)
+            {
+      if (dev->model->is_cis)
+        val =
+          line[i * 2 + j * 2 * pixels + 1] * 256 +
+          line[i * 2 + j * 2 * pixels];
+      else
+        val =
+          line[i * 2 * channels + 2 * j + 1] * 256 +
+          line[i * 2 * channels + 2 * j];
+            }
+          else
+            {
+      if (dev->model->is_cis)
+        val = line[i + j * pixels];
+      else
+        val = line[i * channels + j];
+            }
+
+        max[j] += val;
+    }
+      max[j] = max[j] / (pixels/2);
+
+      gain[j] = ((float) dev->sensor.gain_white_ref*coeff) / max[j];
+
+      /* turn logical gain value into gain code, checking for overflow */
+      code = 283 - 208 / gain[j];
+      if (code > 255)
+    code = 255;
+      else if (code < 0)
+    code = 0;
+      dev->frontend.gain[j] = code;
+
+      DBG (DBG_proc,
+       "gl125_coarse_gain_calibration: channel %d, max=%d, gain = %f, setting:%d\n",
+       j, max[j], gain[j], dev->frontend.gain[j]);
+    }
+
+  if (dev->model->is_cis)
+    {
+      if (dev->frontend.gain[0] > dev->frontend.gain[1])
+    dev->frontend.gain[0] = dev->frontend.gain[1];
+      if (dev->frontend.gain[0] > dev->frontend.gain[2])
+    dev->frontend.gain[0] = dev->frontend.gain[2];
+      dev->frontend.gain[2] = dev->frontend.gain[1] = dev->frontend.gain[0];
+    }
+
+  if (channels == 1)
+    {
+      dev->frontend.gain[0] = dev->frontend.gain[1];
+      dev->frontend.gain[2] = dev->frontend.gain[1];
+    }
+
+  free (line);
+
+  RIE (gl125_stop_action (dev));
+
+  status = gl125_slow_back_home (dev, SANE_TRUE);
+
+  DBGCOMPLETED;
+  return status;
+}
+
+/*
+ * wait for lamp warmup by scanning the same line until difference
+ * between 2 scans is below a threshold
+ */
+static SANE_Status
+gl125_init_regs_for_warmup (Genesys_Device * dev,
+                Genesys_Register_Set * reg,
+                int *channels, int *total_size)
+{
+  int num_pixels;
+  SANE_Status status = SANE_STATUS_GOOD;
+
+  DBGSTART;
+  if (dev == NULL || reg == NULL || channels == NULL || total_size == NULL)
+    return SANE_STATUS_INVAL;
+
+  *channels=3;
+
+  memcpy (reg, dev->reg, (GENESYS_GL125_MAX_REGS + 1) * sizeof (Genesys_Register_Set));
+  status = gl125_init_scan_regs (dev,
+                 reg,
+                 dev->sensor.optical_res,
+                 dev->motor.base_ydpi,
+                 dev->sensor.sensor_pixels/4,
+                 0,
+                 dev->sensor.sensor_pixels/2,
+                 1,
+                 8,
+                 *channels,
+                                 dev->settings.scan_method,
+                                 SCAN_MODE_COLOR,
+                 dev->settings.color_filter,
+                 SCAN_FLAG_DISABLE_SHADING |
+                 SCAN_FLAG_DISABLE_GAMMA |
+                 SCAN_FLAG_SINGLE_LINE |
+                 SCAN_FLAG_IGNORE_LINE_DISTANCE);
+
+  if (status != SANE_STATUS_GOOD)
+    {
+      DBG (DBG_error,
+       "gl125_init_regs_for_warmup: failed to setup scan: %s\n",
+       sane_strstatus (status));
+      return status;
+    }
+
+  num_pixels = dev->current_setup.pixels;
+
+  *total_size = num_pixels * 3 * 1;        /* colors * bytes_per_color * scan lines */
+
+  gl125_set_motor_power (reg, SANE_FALSE);
+  RIE (dev->model->cmd_set->bulk_write_register (dev, reg, GENESYS_GL125_MAX_REGS));
+
+  DBGCOMPLETED;
+  return SANE_STATUS_GOOD;
+}
+
+/** @brief default GPIO values
+ * set up GPIO/GPOE for idle state
+ * @param dev device to set up
+ * @return SANE_STATUS_GOOD unless a GPIO register cannot be written
+ */
+static SANE_Status
+gl125_init_gpio (Genesys_Device * dev)
+{
+  SANE_Status status = SANE_STATUS_GOOD;
+  int idx;
+
+  DBGSTART;
+
+  /* per model GPIO layout */
+  if (strcmp (dev->model->name, "canon-lide-110") == 0)
+    {
+      idx = 0;
+    }
+  else if (strcmp (dev->model->name, "canon-lide-110") == 0)
+    {
+      idx = 2;
+    }
+  else
+    {                                /* canon LiDE 210 and 220 case */
+      idx = 1;
+    }
+
+  RIE (sanei_genesys_write_register (dev, REG31, gpios[idx].r31));
+  RIE (sanei_genesys_write_register (dev, REG32, gpios[idx].r32));
+  RIE (sanei_genesys_write_register (dev, REG33, gpios[idx].r33));
+  RIE (sanei_genesys_write_register (dev, REG34, gpios[idx].r34));
+  RIE (sanei_genesys_write_register (dev, REG35, gpios[idx].r35));
+  RIE (sanei_genesys_write_register (dev, REG36, gpios[idx].r36));
+  RIE (sanei_genesys_write_register (dev, REG38, gpios[idx].r38));
+
+  DBGCOMPLETED;
+  return status;
+}
+
+/**
+ * set memory layout by filling values in dedicated registers
+ */
+static SANE_Status
+gl125_init_memory_layout (Genesys_Device * dev)
+{
+  SANE_Status status = SANE_STATUS_GOOD;
+  int idx = 0;
+
+  DBGSTART;
+
+  /* point to per model memory layout */
+  if ((strcmp (dev->model->name, "canon-lide-110") == 0)
+    ||(strcmp (dev->model->name, "canon-lide-120") == 0))
+    {
+      idx = 0;
+    }
+  else
+    {                                /* canon LiDE 210 and 220 case */
+      idx = 1;
+    }
+
+  /* setup base address for shading data. */
+  /* values must be multiplied by 8192=0x4000 to give address on AHB */
+  /* R-Channel shading bank0 address setting for CIS */
+  sanei_genesys_write_register (dev, 0xd0, layouts[idx].rd0);
+  /* G-Channel shading bank0 address setting for CIS */
+  sanei_genesys_write_register (dev, 0xd1, layouts[idx].rd1);
+  /* B-Channel shading bank0 address setting for CIS */
+  sanei_genesys_write_register (dev, 0xd2, layouts[idx].rd2);
+
+  /* setup base address for scanned data. */
+  /* values must be multiplied by 1024*2=0x0800 to give address on AHB */
+  /* R-Channel ODD image buffer 0x0124->0x92000 */
+  /* size for each buffer is 0x16d*1k word */
+  sanei_genesys_write_register (dev, 0xe0, layouts[idx].re0);
+  sanei_genesys_write_register (dev, 0xe1, layouts[idx].re1);
+  /* R-Channel ODD image buffer end-address 0x0291->0x148800 => size=0xB6800*/
+  sanei_genesys_write_register (dev, 0xe2, layouts[idx].re2);
+  sanei_genesys_write_register (dev, 0xe3, layouts[idx].re3);
+
+  /* R-Channel EVEN image buffer 0x0292 */
+  sanei_genesys_write_register (dev, 0xe4, layouts[idx].re4);
+  sanei_genesys_write_register (dev, 0xe5, layouts[idx].re5);
+  /* R-Channel EVEN image buffer end-address 0x03ff*/
+  sanei_genesys_write_register (dev, 0xe6, layouts[idx].re6);
+  sanei_genesys_write_register (dev, 0xe7, layouts[idx].re7);
+
+  /* same for green, since CIS, same addresses */
+  sanei_genesys_write_register (dev, 0xe8, layouts[idx].re0);
+  sanei_genesys_write_register (dev, 0xe9, layouts[idx].re1);
+  sanei_genesys_write_register (dev, 0xea, layouts[idx].re2);
+  sanei_genesys_write_register (dev, 0xeb, layouts[idx].re3);
+  sanei_genesys_write_register (dev, 0xec, layouts[idx].re4);
+  sanei_genesys_write_register (dev, 0xed, layouts[idx].re5);
+  sanei_genesys_write_register (dev, 0xee, layouts[idx].re6);
+  sanei_genesys_write_register (dev, 0xef, layouts[idx].re7);
+
+/* same for blue, since CIS, same addresses */
+  sanei_genesys_write_register (dev, 0xf0, layouts[idx].re0);
+  sanei_genesys_write_register (dev, 0xf1, layouts[idx].re1);
+  sanei_genesys_write_register (dev, 0xf2, layouts[idx].re2);
+  sanei_genesys_write_register (dev, 0xf3, layouts[idx].re3);
+  sanei_genesys_write_register (dev, 0xf4, layouts[idx].re4);
+  sanei_genesys_write_register (dev, 0xf5, layouts[idx].re5);
+  sanei_genesys_write_register (dev, 0xf6, layouts[idx].re6);
+  sanei_genesys_write_register (dev, 0xf7, layouts[idx].re7);
+
+  DBGCOMPLETED;
+  return status;
+}
+
+/**
+ * initialize backend and ASIC : registers, motor tables, and gamma tables
+ * then ensure scanner's head is at home
+ */
+#ifndef UNIT_TESTING
+static
+#endif
+SANE_Status
+gl125_init (Genesys_Device * dev)
+{
+  SANE_Status status;
+
+  DBG_INIT ();
+  DBGSTART;
+
+  status=sanei_genesys_asic_init(dev, GENESYS_GL125_MAX_REGS);
+
+  DBGCOMPLETED;
+  return status;
+}
+
+
+/* *
+ * initialize ASIC from power on condition
+ */
+static SANE_Status
+gl125_boot (Genesys_Device * dev, SANE_Bool cold)
+{
+  SANE_Status status;
+  uint8_t val;
+
+  DBGSTART;
+
+  /* reset ASIC in case of cold boot */
+  if(cold)
+    {
+      RIE (sanei_genesys_write_register (dev, 0x0e, 0x01));
+      RIE (sanei_genesys_write_register (dev, 0x0e, 0x00));
+    }
+
+  /* enable GPOE 17 */
+  RIE (sanei_genesys_write_register (dev, 0x36, 0x01));
+
+  /* set GPIO 17 */
+  RIE (sanei_genesys_read_register (dev, 0x33, &val));
+  val |= 0x01;
+  RIE (sanei_genesys_write_register (dev, 0x33, val));
+
+  /* test CHKVER */
+  RIE (sanei_genesys_read_register (dev, REG100, &val));
+  if (val & REG100_CHKVER)
+    {
+      RIE (sanei_genesys_read_register (dev, 0x00, &val));
+      DBG (DBG_info,
+       "gl125_cold_boot: reported version for genesys chip is 0x%02x\n",
+       val);
+    }
+
+  /* Set default values for registers */
+  gl125_init_registers (dev);
+
+  /* Write initial registers */
+  RIE (dev->model->cmd_set->bulk_write_register (dev, dev->reg, GENESYS_GL125_MAX_REGS));
+
+  /* tune reg 0B */
+  val = REG0B_30MHZ | REG0B_ENBDRAM | REG0B_64M;
+  RIE (sanei_genesys_write_register (dev, REG0B, val));
+  dev->reg[reg_0x0b].address = 0x00;
+
+  /* set up end access */
+  RIE (sanei_genesys_write_0x8c (dev, 0x10, 0x0b));
+  RIE (sanei_genesys_write_0x8c (dev, 0x13, 0x0e));
+
+  /* CIS_LINE */
+  SETREG (0x08, REG08_CIS_LINE);
+  RIE (sanei_genesys_write_register (dev, 0x08, dev->reg[reg_0x08].value));
+
+  /* setup gpio */
+  RIE (gl125_init_gpio (dev));
+
+  /* setup internal memory layout */
+  RIE (gl125_init_memory_layout (dev));
+
+  DBGCOMPLETED;
+  return SANE_STATUS_GOOD;
+}
+
+
+static SANE_Status
+gl125_update_hardware_sensors (Genesys_Scanner * s)
+{
+  /* do what is needed to get a new set of events, but try to not loose
+     any of them.
+   */
+  SANE_Status status = SANE_STATUS_GOOD;
+  uint8_t val=0;
+
+  RIE (sanei_genesys_read_register (s->dev, REG31, &val));
+
+  /* TODO : for the next scanner special case,
+   * add another per scanner button profile struct to avoid growing
+   * hard-coded button mapping here.
+   */
+  if((s->dev->model->gpo_type == GPO_CANONLIDE110)
+    ||(s->dev->model->gpo_type == GPO_CANONLIDE120))
+    {
+      if (s->val[OPT_SCAN_SW].b == s->last_val[OPT_SCAN_SW].b)
+        s->val[OPT_SCAN_SW].b = (val & 0x01) == 0;
+      if (s->val[OPT_FILE_SW].b == s->last_val[OPT_FILE_SW].b)
+        s->val[OPT_FILE_SW].b = (val & 0x08) == 0;
+      if (s->val[OPT_EMAIL_SW].b == s->last_val[OPT_EMAIL_SW].b)
+        s->val[OPT_EMAIL_SW].b = (val & 0x04) == 0;
+      if (s->val[OPT_COPY_SW].b == s->last_val[OPT_COPY_SW].b)
+        s->val[OPT_COPY_SW].b = (val & 0x02) == 0;
+    }
+  else
+    { /* LiDE 210 case */
+      if (s->val[OPT_EXTRA_SW].b == s->last_val[OPT_EXTRA_SW].b)
+        s->val[OPT_EXTRA_SW].b = (val & 0x01) == 0;
+      if (s->val[OPT_SCAN_SW].b == s->last_val[OPT_SCAN_SW].b)
+        s->val[OPT_SCAN_SW].b = (val & 0x02) == 0;
+      if (s->val[OPT_COPY_SW].b == s->last_val[OPT_COPY_SW].b)
+        s->val[OPT_COPY_SW].b = (val & 0x04) == 0;
+      if (s->val[OPT_EMAIL_SW].b == s->last_val[OPT_EMAIL_SW].b)
+        s->val[OPT_EMAIL_SW].b = (val & 0x08) == 0;
+      if (s->val[OPT_FILE_SW].b == s->last_val[OPT_FILE_SW].b)
+        s->val[OPT_FILE_SW].b = (val & 0x10) == 0;
+    }
+  return status;
+}
+
+
+/** the gl125 command set */
+static Genesys_Command_Set gl125_cmd_set = {
+  "gl125-generic",                /* the name of this set */
+
+  gl125_init,
+  gl125_init_regs_for_warmup,
+  gl125_init_regs_for_coarse_calibration,
+  gl125_init_regs_for_shading,
+  gl125_init_regs_for_scan,
+
+  gl125_get_filter_bit,
+  gl125_get_lineart_bit,
+  gl125_get_bitset_bit,
+  gl125_get_gain4_bit,
+  gl125_get_fast_feed_bit,
+  gl125_test_buffer_empty_bit,
+  gl125_test_motor_flag_bit,
+
+  gl125_bulk_full_size,
+
+  gl125_set_fe,
+  gl125_set_powersaving,
+  gl125_save_power,
+
+  gl125_set_motor_power,
+  gl125_set_lamp_power,
+
+  gl125_begin_scan,
+  gl125_end_scan,
+
+  sanei_genesys_send_gamma_table,
+
+  gl125_search_start_position,
+
+  gl125_offset_calibration,
+  gl125_coarse_gain_calibration,
+  gl125_led_calibration,
+
+  gl125_slow_back_home,
+  gl125_rewind,
+
+  sanei_genesys_bulk_write_register,
+  NULL,
+  gl125_bulk_read_data,
+
+  gl125_update_hardware_sensors,
+
+  /* no sheetfed support for now */
+  NULL,
+  NULL,
+  NULL,
+  NULL,
+
+  sanei_genesys_is_compatible_calibration,
+  NULL,
+  gl125_send_shading_data,
+  gl125_calculate_current_setup,
+  gl125_boot,
+  gl125_init_scan_regs
+};
+
+SANE_Status
+sanei_gl125_init_cmd_set (Genesys_Device * dev)
+{
+  dev->model->cmd_set = &gl125_cmd_set;
+  return SANE_STATUS_GOOD;
+}
+
+/* vim: set sw=2 cino=>2se-1sn-1s{s^-1st0(0u0 smarttab expandtab: */
diff --git a/backend/genesys_gl125.h b/backend/genesys_gl125.h
new file mode 100644
index 0000000..2bfe121
--- /dev/null
+++ b/backend/genesys_gl125.h
@@ -0,0 +1,757 @@
+/* sane - Scanner Access Now Easy.
+
+   Copyright (C) 2010-2016 St√©phane Voltz <stef.dev@free.fr>
+
+   This file is part of the SANE package.
+
+   This program is free software; you can redistribute it and/or
+   modify it under the terms of the GNU General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA.
+
+   As a special exception, the authors of SANE give permission for
+   additional uses of the libraries contained in this release of SANE.
+
+   The exception is that, if you link a SANE library with other files
+   to produce an executable, this does not by itself cause the
+   resulting executable to be covered by the GNU General Public
+   License.  Your use of that executable is in no way restricted on
+   account of linking the SANE library code into it.
+
+   This exception does not, however, invalidate any other reasons why
+   the executable file might be covered by the GNU General Public
+   License.
+
+   If you submit changes to SANE to the maintainers to be included in
+   a subsequent release, you agree by submitting the changes that
+   those changes may be distributed with this exception intact.
+
+   If you write modifications of your own for SANE, it is your choice
+   whether to permit this exception to apply to your modifications.
+   If you do not wish that, delete this exception notice.
+*/
+
+#include "genesys.h"
+
+#define REG01           0x01
+#define REG01_CISSET    0x80
+#define REG01_DOGENB    0x40
+#define REG01_DVDSET    0x20
+#define REG01_STAGGER   0x10
+#define REG01_COMPENB   0x08
+#define REG01_TRUEGRAY  0x04
+#define REG01_SHDAREA   0x02
+#define REG01_SCAN      0x01
+
+#define REG02           0x02
+#define REG02_NOTHOME   0x80
+#define REG02_ACDCDIS   0x40
+#define REG02_AGOHOME   0x20
+#define REG02_MTRPWR    0x10
+#define REG02_FASTFED   0x08
+#define REG02_MTRREV    0x04
+#define REG02_HOMENEG   0x02
+#define REG02_LONGCURV  0x01
+
+#define REG03           0x03
+#define REG03_LAMPDOG   0x80
+#define REG03_AVEENB    0x40
+#define REG03_XPASEL    0x20
+#define REG03_LAMPPWR   0x10
+#define REG03_LAMPTIM   0x0f
+
+#define REG04           0x04
+#define REG04_LINEART   0x80
+#define REG04_BITSET    0x40
+#define REG04_FILTER    0x30
+#define REG04_AFEMOD    0x07
+
+#define REG05           0x05
+#define REG05_DPIHW     0xc0
+#define REG05_DPIHW_600  0x00
+#define REG05_DPIHW_1200 0x40
+#define REG05_DPIHW_2400 0x80
+#define REG05_DPIHW_4800 0xc0
+#define REG05_MTLLAMP   0x30
+#define REG05_GMMENB    0x08
+#define REG05_ENB20M    0x04
+#define REG05_MTLBASE   0x03
+
+#define REG06           0x06
+#define REG06_SCANMOD   0xe0
+#define REG06S_SCANMOD     5
+#define REG06_PWRBIT    0x10
+#define REG06_GAIN4     0x08
+#define REG06_OPTEST    0x07
+
+#define REG07_LAMPSIM   0x80
+
+#define REG08_DRAM2X    0x80
+#define REG08_MPENB     0x20
+#define REG08_CIS_LINE  0x10
+#define REG08_IR2_ENB   0x08
+#define REG08_IR1_ENB   0x04
+#define REG08_ENB24M    0x01
+
+#define REG09_MCNTSET   0xc0
+#define REG09_EVEN1ST   0x20
+#define REG09_BLINE1ST  0x10
+#define REG09_BACKSCAN  0x08
+#define REG09_OUTINV    0x04
+#define REG09_SHORTTG   0x02
+
+#define REG09S_MCNTSET  6
+#define REG09S_CLKSET   4
+
+#define REG0A           0x0a
+#define REG0A_SIFSEL    0xc0
+#define REG0AS_SIFSEL   6
+#define REG0A_SHEETFED  0x20
+#define REG0A_LPWMEN    0x10
+
+#define REG0B           0x0b
+#define REG0B_DRAMSEL   0x07
+#define REG0B_16M       0x01
+#define REG0B_64M       0x02
+#define REG0B_128M      0x03
+#define REG0B_256M      0x04
+#define REG0B_512M      0x05
+#define REG0B_1G        0x06
+#define REG0B_ENBDRAM   0x08
+#define REG0B_RFHDIS    0x10
+#define REG0B_CLKSET    0xe0
+#define REG0B_24MHZ     0x00
+#define REG0B_30MHZ     0x20
+#define REG0B_40MHZ     0x40
+#define REG0B_48MHZ     0x60
+#define REG0B_60MHZ     0x80
+
+#define REG0D           0x0d
+#define REG0D_MTRP_RDY  0x80
+#define REG0D_FULLSTP   0x10
+#define REG0D_CLRMCNT   0x04
+#define REG0D_CLRDOCJM  0x02
+#define REG0D_CLRLNCNT  0x01
+
+#define REG0F           0x0f
+
+#define REG16_CTRLHI    0x80
+#define REG16_TOSHIBA   0x40
+#define REG16_TGINV     0x20
+#define REG16_CK1INV    0x10
+#define REG16_CK2INV    0x08
+#define REG16_CTRLINV   0x04
+#define REG16_CKDIS     0x02
+#define REG16_CTRLDIS   0x01
+
+#define REG17_TGMODE    0xc0
+#define REG17_SNRSYN    0x0f
+
+#define REG18           0x18
+#define REG18_CNSET     0x80
+#define REG18_DCKSEL    0x60
+#define REG18_CKTOGGLE  0x10
+#define REG18_CKDELAY   0x0c
+#define REG18_CKSEL     0x03
+
+#define REG1A_SW2SET    0x80
+#define REG1A_SW1SET    0x40
+#define REG1A_MANUAL3   0x02
+#define REG1A_MANUAL1   0x01
+#define REG1A_CK4INV    0x08
+#define REG1A_CK3INV    0x04
+#define REG1A_LINECLP   0x02
+
+#define REG1C_TBTIME    0x07
+
+#define REG1D           0x1d
+#define REG1D_CK4LOW    0x80
+#define REG1D_CK3LOW    0x40
+#define REG1D_CK1LOW    0x20
+#define REG1D_LINESEL   0x1f
+#define REG1DS_LINESEL  0
+
+#define REG1E           0x1e
+#define REG1E_WDTIME    0xf0
+#define REG1ES_WDTIME   4
+#define REG1E_WDTIME    0xf0
+
+#define REG30           0x30
+#define REG31           0x31
+#define REG32           0x32
+#define REG32_GPIO16    0x80
+#define REG32_GPIO15    0x40
+#define REG32_GPIO14    0x20
+#define REG32_GPIO13    0x10
+#define REG32_GPIO12    0x08
+#define REG32_GPIO11    0x04
+#define REG32_GPIO10    0x02
+#define REG32_GPIO9     0x01
+#define REG33           0x33
+#define REG34           0x34
+#define REG35           0x35
+#define REG36           0x36
+#define REG37           0x37
+#define REG38           0x38
+#define REG39           0x39
+
+#define REG60           0x60
+#define REG60_LED4TG    0x80
+#define REG60_YENB      0x40
+#define REG60_YBIT      0x20
+#define REG60_ACYNCNRLC 0x10
+#define REG60_ENOFFSET  0x08
+#define REG60_LEDADD    0x04
+#define REG60_CK4ADC    0x02
+#define REG60_AUTOCONF  0x01
+
+#define REG80           0x80
+#define REG81           0x81
+
+#define REGA0           0xa0
+#define REGA0_FSTPSEL   0x28
+#define REGA0S_FSTPSEL  3
+#define REGA0_STEPSEL   0x03
+#define REGA0S_STEPSEL  0
+
+#define REGA1           0xa1
+#define REGA2           0xa2
+#define REGA3           0xa3
+#define REGA4           0xa4
+#define REGA5           0xa5
+#define REGA6           0xa6
+#define REGA7           0xa7
+#define REGA8           0xa8
+#define REGA9           0xa9
+#define REGAA           0xaa
+#define REGAB           0xab
+#define REGAC           0xac
+#define REGAD           0xad
+#define REGAE           0xae
+#define REGAF           0xaf
+#define REGB0           0xb0
+#define REGB1           0xb1
+
+#define REGB2           0xb2
+#define REGB2_Z1MOD     0x1f
+#define REGB3           0xb3
+#define REGB3_Z1MOD     0xff
+#define REGB4           0xb4
+#define REGB4_Z1MOD     0xff
+
+#define REGB5           0xb5
+#define REGB5_Z2MOD     0x1f
+#define REGB6           0xb6
+#define REGB6_Z2MOD     0xff
+#define REGB7           0xb7
+#define REGB7_Z2MOD     0xff
+
+#define REG100          0x100
+#define REG100_DOCSNR   0x80
+#define REG100_ADFSNR   0x40
+#define REG100_COVERSNR 0x20
+#define REG100_CHKVER   0x10
+#define REG100_DOCJAM   0x08
+#define REG100_HISPDFLG 0x04
+#define REG100_MOTMFLG  0x02
+#define REG100_DATAENB  0x01
+
+#define REG114          0x114
+#define REG115          0x115
+
+#define REG_LINCNT      0x25
+#define REG_MAXWD       0x28
+#define REG_DPISET      0x2c
+#define REG_FEEDL       0x3d
+#define REG_CK1MAP      0x74
+#define REG_CK3MAP      0x77
+#define REG_CK4MAP      0x7a
+#define REG_LPERIOD     0x7d
+#define REG_DUMMY       0x80
+#define REG_STRPIXEL    0x82
+#define REG_ENDPIXEL    0x85
+#define REG_EXPDMY      0x88
+#define REG_EXPR        0x8a
+#define REG_EXPG        0x8d
+#define REG_EXPB        0x90
+#define REG_SEGCNT      0x93
+#define REG_TG0CNT      0x96
+#define REG_SCANFED     0xa2
+#define REG_STEPNO      0xa4
+#define REG_FWDSTEP     0xa6
+#define REG_BWDSTEP     0xa8
+#define REG_FASTNO      0xaa
+#define REG_FSHDEC      0xac
+#define REG_FMOVNO      0xae
+#define REG_FMOVDEC     0xb0
+#define REG_Z1MOD       0xb2
+#define REG_Z2MOD       0xb5
+
+#define REG_TRUER       0x110
+#define REG_TRUEG       0x111
+#define REG_TRUEB       0x112
+
+/**
+ * writable scanner registers */
+enum
+{
+  reg_0x01 = 0,
+  reg_0x02,
+  reg_0x03,
+  reg_0x04,
+  reg_0x05,
+  reg_0x06,
+  reg_0x07,
+  reg_0x08,
+  reg_0x09,
+  reg_0x0a,
+  reg_0x0b,
+  reg_0x0c,
+  reg_0x11,
+  reg_0x12,
+  reg_0x13,
+  reg_0x14,
+  reg_0x15,
+  reg_0x16,
+  reg_0x17,
+  reg_0x18,
+  reg_0x19,
+  reg_0x1a,
+  reg_0x1b,
+  reg_0x1c,
+  reg_0x1d,
+  reg_0x1e,
+  reg_0x1f,
+  reg_0x20,
+  reg_0x21,
+  reg_0x22,
+  reg_0x23,
+  reg_0x24,
+  reg_0x25,
+  reg_0x26,
+  reg_0x27,
+  reg_0x28,
+  reg_0x29,
+  reg_0x2a,
+  reg_0x2b,
+  reg_0x2c,
+  reg_0x2d,
+  reg_0x3b,
+  reg_0x3c,
+  reg_0x3d,
+  reg_0x3e,
+  reg_0x3f,
+  reg_0x40,
+  reg_0x41,
+  reg_0x42,
+  reg_0x43,
+  reg_0x44,
+  reg_0x45,
+  reg_0x46,
+  reg_0x47,
+  reg_0x48,
+  reg_0x49,
+  reg_0x4f,
+  reg_0x52,
+  reg_0x53,
+  reg_0x54,
+  reg_0x55,
+  reg_0x56,
+  reg_0x57,
+  reg_0x58,
+  reg_0x59,
+  reg_0x5a,
+  reg_0x5b,
+  reg_0x5c,
+  reg_0x5f,
+  reg_0x60,
+  reg_0x61,
+  reg_0x62,
+  reg_0x63,
+  reg_0x64,
+  reg_0x65,
+  reg_0x66,
+  reg_0x67,
+  reg_0x68,
+  reg_0x69,
+  reg_0x6a,
+  reg_0x6b,
+  reg_0x6c,
+  reg_0x6d,
+  reg_0x6e,
+  reg_0x6f,
+  reg_0x70,
+  reg_0x71,
+  reg_0x72,
+  reg_0x73,
+  reg_0x74,
+  reg_0x75,
+  reg_0x76,
+  reg_0x77,
+  reg_0x78,
+  reg_0x79,
+  reg_0x7a,
+  reg_0x7b,
+  reg_0x7c,
+  reg_0x7d,
+  reg_0x7e,
+  reg_0x7f,
+  reg_0x80,
+  reg_0x81,
+  reg_0x82,
+  reg_0x83,
+  reg_0x84,
+  reg_0x85,
+  reg_0x86,
+  reg_0x87,
+  reg_0x88,
+  reg_0x89,
+  reg_0x8a,
+  reg_0x8b,
+  reg_0x8c,
+  reg_0x8d,
+  reg_0x8e,
+  reg_0x8f,
+  reg_0x90,
+  reg_0x91,
+  reg_0x92,
+  reg_0x93,
+  reg_0x94,
+  reg_0x95,
+  reg_0x96,
+  reg_0x97,
+  reg_0x98,
+  reg_0x99,
+  reg_0x9a,
+  reg_0x9b,
+  reg_0x9c,
+  reg_0x9d,
+  reg_0x9e,
+  reg_0x9f,
+  reg_0xa0,
+  reg_0xa1,
+  reg_0xa2,
+  reg_0xa3,
+  reg_0xa4,
+  reg_0xa5,
+  reg_0xa6,
+  reg_0xa7,
+  reg_0xa8,
+  reg_0xa9,
+  reg_0xaa,
+  reg_0xab,
+  reg_0xac,
+  reg_0xad,
+  reg_0xae,
+  reg_0xaf,
+  reg_0xb0,
+  reg_0xb1,
+  reg_0xb2,
+  reg_0xb3,
+  reg_0xb4,
+  reg_0xb5,
+  reg_0xb6,
+  reg_0xb7,
+  reg_0xb8,
+  reg_0xbb,
+  reg_0xbc,
+  reg_0xbd,
+  reg_0xbe,
+  reg_0xc3,
+  reg_0xc4,
+  reg_0xc5,
+  reg_0xc6,
+  reg_0xc7,
+  reg_0xc8,
+  reg_0xc9,
+  reg_0xca,
+  reg_0xcb,
+  reg_0xcc,
+  reg_0xcd,
+  reg_0xce,
+  reg_0xd0,
+  reg_0xd1,
+  reg_0xd2,
+  reg_0xd3,
+  reg_0xd4,
+  reg_0xd5,
+  reg_0xd6,
+  reg_0xd7,
+  reg_0xd8,
+  reg_0xd9,
+  reg_0xe0,
+  reg_0xe1,
+  reg_0xe2,
+  reg_0xe3,
+  reg_0xe4,
+  reg_0xe5,
+  reg_0xe6,
+  reg_0xe7,
+  reg_0xe8,
+  reg_0xe9,
+  reg_0xea,
+  reg_0xeb,
+  reg_0xec,
+  reg_0xed,
+  reg_0xee,
+  reg_0xef,
+  reg_0xf0,
+  reg_0xf1,
+  reg_0xf2,
+  reg_0xf3,
+  reg_0xf4,
+  reg_0xf5,
+  reg_0xf6,
+  reg_0xf7,
+  reg_0xf8,
+  reg_0xf9,
+  reg_0xfa,
+  reg_0xfb,
+  reg_0xfc,
+  reg_0xff,
+  GENESYS_GL125_MAX_REGS
+};
+
+#define SETREG(adr,val) {dev->reg[reg_##adr].address=adr;dev->reg[reg_##adr].value=val;}
+
+typedef struct
+{
+  uint8_t r31;
+  uint8_t r32;
+  uint8_t r33;
+  uint8_t r34;
+  uint8_t r35;
+  uint8_t r36;
+  uint8_t r38;
+} Gpio_layout;
+
+/** @brief gpio layout
+ * describes initial gpio settings for a given model
+ * registers 0x31 to 0x38
+ */
+static Gpio_layout gpios[]={
+    /* LiDE 110 */
+    { /*    0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x38 */
+        0x9f, 0x59, 0x01, 0x80, 0x5f, 0x01, 0x00
+    },
+    /* LiDE 210 */
+    {
+        0x9f, 0x59, 0x01, 0x80, 0x5f, 0x01, 0x00
+    },
+    /* LiDE 120 */
+    {
+        0x9f, 0x53, 0x01, 0x80, 0x5f, 0x01, 0x00
+    },
+};
+
+typedef struct
+{
+  uint8_t rd0;
+  uint8_t rd1;
+  uint8_t rd2;
+  uint8_t re0;
+  uint8_t re1;
+  uint8_t re2;
+  uint8_t re3;
+  uint8_t re4;
+  uint8_t re5;
+  uint8_t re6;
+  uint8_t re7;
+} Memory_layout;
+
+static Memory_layout layouts[]={
+    /* LIDE 110, 120 */
+    {    /* 0xd0 0xd1 0xd2 */
+        0x0a, 0x15, 0x20,
+         /* 0xe0  0xe1  0xe2  0xe3  0xe4  0xe5  0xe6  0xe7 */
+        0x00, 0xac, 0x08, 0x55, 0x08, 0x56, 0x0f, 0xff
+    },
+    /* LIDE 210, 220 */
+    {
+        0x0a, 0x1f, 0x34,
+        0x01, 0x24, 0x08, 0x91, 0x08, 0x92, 0x0f, 0xff
+    }
+};
+
+/** @brief structure for sensor settings
+ * this structure describes the sensor settings to use for a given
+ * exposure. Data settings are identified by
+ * - sensor id
+ * - sensor hardware dpi
+ * - half ccd mode
+ */
+typedef struct {
+  int sensor_type;      /**> sensor id */
+  int dpi;              /**> maximum dpi for which data are valid */
+  int half_ccd;         /**> half ccd mode  */
+  int exposure;         /**> exposure */
+  int ck1map;           /**> CK1MAP */
+  int ck3map;           /**> CK3MAP */
+  int ck4map;           /**> CK4MAP */
+  int segcnt;           /**> SEGCNT */
+  int tg0cnt;           /**> TG0CNT */
+  int expdummy;         /**> exposure dummy */
+  int expr;             /**> initial red exposure */
+  int expg;             /**> initial green exposure */
+  int expb;             /**> initial blue exposure */
+  size_t *order;        /**> order of sub-segments */
+  uint8_t reg18;        /**> register 0x18 value */
+  uint8_t reg20;        /**> register 0x20 value */
+  uint8_t reg61;        /**> register 0x61 value */
+  uint8_t reg98;        /**> register 0x98 value */
+  uint8_t reg16;        /**> register 0x16 value */
+  uint8_t reg70;        /**> register 0x70 value */
+} Sensor_Profile;
+
+static size_t order_01[]={0,1};
+static size_t order_0213[]={0,2,1,3};
+
+/* *INDENT-OFF* */
+
+/** @brief database of sensor profiles
+ * database of sensor profiles giving for each sensor and a given resolution, the period, and timings
+ * to setup the sensor for the scan.
+ */
+static Sensor_Profile sensors[]={
+        /* LiDE 110 */
+    {CIS_CANONLIDE110,  600, 1,  2768, 0x1e, 0x9f, 0x55, 2584, 154,  101,  388,  574,  393, NULL      , 0x00, 0x0c, 0x20, 0x21, 0x00, 0x00},
+    {CIS_CANONLIDE110,  600, 0,  5360, 0x1e, 0x9f, 0x55, 5168, 163,  101,  388,  574,  393, NULL      , 0x00, 0x0a, 0x20, 0x21, 0x00, 0x00},
+    {CIS_CANONLIDE110, 1200, 0, 10528, 0x1e, 0x9f, 0x55, 5168, 163,  101,  388,  574,  393, order_01  , 0x00, 0x08, 0x20, 0x22, 0x00, 0x00},
+    {CIS_CANONLIDE110, 2400, 0, 20864, 0x1e, 0x9f, 0x55, 5168, 163, 4679, 6839, 8401, 6859, order_0213, 0x00, 0x06, 0x20, 0x24, 0x00, 0x00},
+
+    /* LiDE 120 */
+    {CIS_CANONLIDE120,  600, 1,  4608, 0x0f, 0x00, 0x55, 2552, 112,   94,  894, 1044,  994, NULL      , 0x00, 0x02, 0x20, 0x21, 0x15, 0x00},
+    {CIS_CANONLIDE120,  600, 0,  5360, 0x0f, 0x00, 0x55, 5104, 139,   94, 1644, 1994, 1844, NULL      , 0x00, 0x02, 0x20, 0x21, 0x11, 0x1f},
+    {CIS_CANONLIDE120, 1200, 0, 10528, 0x0f, 0x00, 0x55,10208, 192,   94, 3194, 3794, 3594, NULL      , 0x00, 0x02, 0x20, 0x21, 0x15, 0x1f},
+    {CIS_CANONLIDE120, 2400, 0, 20864, 0x0f, 0x00, 0x55,20416, 298,   94, 6244, 7544, 7094, NULL      , 0x00, 0x02, 0x20, 0x21, 0x11, 0x00},
+
+        /* LiDE 210 */
+    {CIS_CANONLIDE210,  600, 1,  2768, 0x1e, 0x9f, 0x55, 2584, 154,  101,  388,  574,  393, NULL      , 0x00, 0x0c, 0x20, 0x21, 0x00, 0x00},
+    {CIS_CANONLIDE210,  600, 0,  5360, 0x1e, 0x9f, 0x55, 5168, 163,  101,  388,  574,  393, NULL      , 0x00, 0x0a, 0x20, 0x21, 0x00, 0x00},
+    {CIS_CANONLIDE210, 1200, 0, 10528, 0x1e, 0x9f, 0x55, 5168, 163,  101,  388,  574,  393, order_01  , 0x00, 0x08, 0x20, 0x22, 0x00, 0x00},
+    {CIS_CANONLIDE210, 2400, 0, 20864, 0x1e, 0x9f, 0x55, 5168, 163, 4679, 6839, 8401, 6859, order_0213, 0x00, 0x06, 0x20, 0x24, 0x00, 0x00},
+
+        /* LiDE 220 */
+    {CIS_CANONLIDE220,  600, 1,  2768, 0x0f, 0x9f, 0x55, 2584, 154,  101,  388,  574,  393, NULL      , 0x00, 0x0c, 0x20, 0x21, 0x00, 0x00},
+    {CIS_CANONLIDE220,  600, 0,  5360, 0x0f, 0x9f, 0x55, 5168, 163,  101,  388,  574,  393, NULL      , 0x00, 0x0a, 0x20, 0x21, 0x00, 0x00},
+    {CIS_CANONLIDE220, 1200, 0, 10528, 0x0f, 0x9f, 0x55, 5168, 163,  101,  388,  574,  393, order_01  , 0x00, 0x08, 0x20, 0x22, 0x00, 0x00},
+    {CIS_CANONLIDE220, 2400, 0, 20864, 0x0f, 0x9f, 0x55, 5168, 163, 4679, 6839, 8401, 6859, order_0213, 0x00, 0x06, 0x20, 0x24, 0x00, 0x00},
+
+
+        /* ScanJet 200 */
+    {CIS_HPSJ200,  600, 1,  2768, 0x0f, 0x9f, 0x55, 2584, 154,  101,  388,  574,  393, NULL      , 0x00, 0x0c, 0x20, 0x21, 0x00, 0x00},
+    {CIS_HPSJ200,  600, 0,  5360, 0x0f, 0x9f, 0x55, 5168, 163,  101,  388,  574,  393, NULL      , 0x00, 0x0a, 0x20, 0x21, 0x00, 0x00},
+    {CIS_HPSJ200, 1200, 0, 10528, 0x0f, 0x9f, 0x55, 5168, 163,  101,  388,  574,  393, order_01  , 0x00, 0x08, 0x20, 0x22, 0x00, 0x00},
+    {CIS_HPSJ200, 2400, 0, 20864, 0x0f, 0x9f, 0x55, 5168, 163, 4679, 6839, 8401, 6859, order_0213, 0x00, 0x06, 0x20, 0x24, 0x00, 0x00},
+};
+
+
+#define MOVE_DPI 200
+#define MOVE_EXPOSURE 2304
+/** @brief reference slope tables
+ * slope table directly extracted from USB logs, with a 'termination' value of 0.
+ */
+static uint32_t lide210_fast[] = { 62496, 2343, 2343, 2343, 2343, 2343, 2343, 2343, 2343, 2051, 1432, 1372, 1323, 1280, 1246, 1216, 1188, 1163, 1142, 1121, 1101, 1084, 1068, 1051, 1036, 1020, 1007, 995, 983, 971, 959, 949, 938, 929, 917, 908, 900, 891, 882, 874, 866, 857, 849, 843, 835, 829, 821, 816, 808, 802, 795, 789, 784, 778, 773, 765, 760, 755, 749, 744, 739, 734, 731, 726, 721, 716, 711, 707, 702, 698, 693, 690, 685, 682, 677, 672, 669, 665, 662, 657, 654, 650, 647, 644, 639, 637, 632, 629, 626, 622, 619, 617, 614, 610, 607, 604, 601, 599, 595, 592, 589, 587, 584, 581, 579, 576, 572, 570, 567, 564, 562, 559, 557, 554, 552, 549, 547, 544, 542, 539, 538, 536, 533, 531, 529, 526, 524, 522, 519, 518, 516, 513, 511, 509, 506, 505, 503, 501, 498, 497, 495, 493, 491, 490, 487, 485, 483, 482, 480, 477, 476, 474, 472, 470, 469, 467, 465, 464, 462, 460, 458, 456, 455, 453, 451, 450, 448, 447, 445, 444, 442, 440, 439, 437, 436, 434, 433, 431, 430, 428, 427, 425, 423, 422, 420, 419, 417, 417, 415, 414, 413, 411, 410, 408, 407, 405, 404, 402, 401, 400, 399, 398, 396, 395, 393, 392, 391, 390, 389, 387, 386, 385, 383, 382, 381, 380, 379, 377, 376, 375, 374, 373, 371, 370, 369, 368, 367, 366, 364, 363, 363, 361, 360, 359, 358, 357, 356, 355, 353, 352, 352, 350, 349, 348, 347, 346, 345, 344, 343, 342, 341, 340, 339, 338, 335, 335, 0};
+static uint32_t lide110_ok[]   = { 62496, 2343, 2343, 2343, 2343, 2343, 2343, 2343, 2343, 2051, 1961, 1901, 1852, 1809, 1775, 1745, 1717, 1692, 1671, 1650, 1630, 1613, 1597, 1580, 1565, 1549, 1536, 1524, 1512, 1500, 1488, 1478, 1467, 1458, 1446, 1437, 1429, 1420, 1411, 1403, 1395, 1386, 1378, 1372, 1364, 1358, 1350, 1345, 1337, 1331, 1324, 1318, 1313, 1307, 1302, 1294, 1289, 1284, 1278, 1273, 1268, 1263, 1260, 1255, 1250, 1245, 1240, 1236, 1231, 1227, 1222, 1219, 1214, 1211, 1206, 1201, 1198, 1194, 1191, 1186, 1183, 1179, 1176, 1173, 1168, 1166, 1161, 1158, 1155, 1151, 1148, 1146, 1143, 1139, 1136, 1133, 1130, 1128, 1124, 1121, 1118, 1116, 1113, 1110, 1108, 1105, 1101, 1099, 1096, 1093, 1091, 1088, 1086, 1083, 1081, 1078, 1076, 1073, 1071, 1068, 1067, 1065, 1062, 1060, 1058, 1055, 1053, 1051, 1048, 1047, 1045, 1042, 1040, 1038, 1035, 1034, 1032, 1030, 1027, 1026, 1024, 1022, 1020, 1019, 1016, 1014, 1012, 1011, 1009, 1006, 1005, 1003, 1001, 999, 998, 996, 994, 993, 991, 989, 987, 985, 984, 982, 980, 979, 977, 976, 974, 973, 971, 969, 968, 966, 965, 963, 962, 960, 959, 957, 956, 954, 952, 951, 949, 948, 946, 946, 944, 943, 942, 940, 939, 937, 936, 934, 933, 931, 930, 929, 928, 927, 925, 924, 922, 921, 920, 919, 918, 916, 915, 914, 912, 911, 910, 909, 908, 906, 905, 904, 903, 902, 900, 899, 898, 897, 896, 895, 893, 892, 892, 890, 889, 888, 887, 886, 885, 884, 882, 881, 881, 879, 878, 877, 876, 875, 874, 873, 872, 871, 870, 869, 868, 867, 864, 857, 849, 843, 835, 829, 821, 816, 808, 802, 795, 789, 784, 778, 773, 765, 760, 755, 749, 744, 739, 734, 731, 726, 721, 716, 711, 707, 702, 698, 693, 690, 685, 682, 677, 672, 669, 665, 662, 657, 654, 650, 647, 644, 639, 637, 632, 629, 626, 622, 619, 617, 614, 610, 607, 604, 601, 599, 595, 592, 589, 587, 584, 581, 579, 576, 572, 570, 567, 564, 562, 559, 557, 554, 552, 549, 547, 544, 542, 539, 538, 536, 533, 531, 529, 526, 524, 522, 519, 518, 516, 513, 511, 509, 506, 505, 503, 501, 498, 497, 495, 493, 491, 490, 487, 485, 483, 482, 480, 477, 476, 474, 472, 470, 469, 467, 465, 464, 462, 460, 458, 456, 455, 453, 451, 450, 448, 447, 445, 444, 442, 440, 439, 437, 436, 434, 433, 431, 430, 428, 427, 425, 423, 422, 420, 419, 417, 417, 415, 414, 413, 411, 410, 408, 407, 405, 404, 402, 401, 400, 399, 398, 396, 395, 393, 392, 391, 390, 389, 387, 386, 385, 383, 382, 381, 380, 379, 377, 376, 375, 374, 373, 371, 370, 369, 368, 367, 366, 364, 363, 363, 361, 360, 359, 358, 357, 356, 355, 353, 352, 352, 350, 349, 348, 347, 346, 345, 344, 343, 342, 341, 340, 339, 338, 335, 335, 0};
+static uint32_t lide120_fast[] = { 62496, 2343, 2343, 2343, 2343, 2343, 2343, 2343, 2343, 1957, 1845, 1768, 1710, 1665, 1624, 1588, 1557, 1529, 1504, 1481, 1458, 1440, 1420, 1403, 1386, 1370, 1356, 1343, 1329, 1316, 1303, 1293, 1280, 1270, 1260, 1250, 1241, 1231, 1222, 1214, 1206, 1197, 1189, 1182, 1174, 1167, 1160, 1153, 1147, 1140, 1133, 1128, 1121, 1116, 1110, 1104, 1099, 1093, 1088, 1082, 1077, 1072, 1067, 1062, 1058, 1053, 1049, 1045, 1040, 1035, 1032, 1027, 1023, 1020, 1015, 1012, 1008, 1004, 1000, 997, 993, 989, 985, 982, 979, 975, 972, 969, 966, 963, 959, 956, 953, 950, 947, 945, 942, 939, 936, 933, 930, 928, 925, 922, 920, 917, 914, 911, 909, 907, 904, 902, 899, 897, 895, 892, 890, 888, 886, 883, 881, 879, 876, 874, 872, 870, 864, 864, 0};
+static uint32_t lide120_ok[]   = { 62496, 2343, 2343, 2343, 2343, 2343, 2343, 2343, 2343, 2286, 2264, 2248, 2232, 2221, 2211, 2205, 2195, 2190, 2180, 2175, 2170, 2160, 2155, 2150, 2145, 2140, 2135, 2130, 2125, 2121, 2116, 2111, 2106, 2106, 2102, 2097, 2092, 2087, 2087, 2083, 2078, 2074, 2074, 2069, 2064, 2064, 2060, 2055, 2055, 2051, 2051, 2046, 2042, 2042, 2038, 2038, 2033, 2029, 2029, 2024, 2024, 2020, 2010, 2010, 670*2, 0};
+static uint32_t lide110_slow[] = { 62496, 7896, 2632, 0};
+static uint32_t lide120_slow[] = { 62464, 7896, 2632, 0};
+static uint32_t lide110_max[]  = { 62496, 31296, 10432, 0};
+static uint32_t lide120_max[]  = { 62592, 62592, 41728, 31296, 10432, 0};
+static uint32_t lide210_max[]  = { 62496, 31296, 20864, 10432, 0};
+
+/* NEXT LPERIOD=PREVIOUS*2-192 */
+/** @brief database of motor profiles
+ * database of motor profiles, for each exposure deigned for the sensor, gives the reference slope table to use
+ * for scan.
+ */
+static Motor_Profile motors[]={
+    {MOTOR_CANONLIDE110,  2768, 0, lide210_fast},
+    {MOTOR_CANONLIDE110,  5360, 1, lide110_ok},
+    {MOTOR_CANONLIDE110, 10528, 1, lide110_slow},
+    {MOTOR_CANONLIDE110, 20864, 2, lide110_max},
+    {MOTOR_CANONLIDE120,  4608, 0, lide120_fast},
+    {MOTOR_CANONLIDE120,  5360, 1, lide120_ok},
+    {MOTOR_CANONLIDE120, 10528, 2, lide120_slow},
+    {MOTOR_CANONLIDE120, 20864, 2, lide120_max},
+    {MOTOR_CANONLIDE210,  2768, 0, lide210_fast},
+    {MOTOR_CANONLIDE210,  5360, 1, lide110_ok},
+    {MOTOR_CANONLIDE210, 10528, 1, lide110_slow},
+    {MOTOR_CANONLIDE210, 20864, 2, lide210_max},
+    {MOTOR_HPSJ200,  2768, 0, lide210_fast},
+    {MOTOR_HPSJ200,  5360, 1, lide110_ok},
+    {MOTOR_HPSJ200, 10528, 1, lide110_slow},
+    {MOTOR_HPSJ200, 20864, 2, lide210_max},
+    {0, 0, 0, NULL},
+};
+/* *INDENT-ON* */
+GENESYS_STATIC
+SANE_Status gl125_init_scan_regs (Genesys_Device * dev,
+                                  Genesys_Register_Set * reg,
+                  float xres,        /*dpi */
+                  float yres,        /*dpi */
+                  float startx,        /*optical_res, from dummy_pixel+1 */
+                  float starty,        /*base_ydpi, from home! */
+                                  float pixels,
+                                  float lines,
+                                  unsigned int depth,
+                                  unsigned int channels,
+                                  int scan_method,
+                                  int scan_mode,
+                                  int color_filter,
+                                  unsigned int flags);
+
+#ifndef UNIT_TESTING
+static
+#endif
+  SANE_Status gl125_start_action (Genesys_Device * dev);
+#ifndef UNIT_TESTING
+static
+#endif
+  SANE_Status
+gl125_begin_scan (Genesys_Device * dev, Genesys_Register_Set * reg,
+          SANE_Bool start_motor);
+#ifndef UNIT_TESTING
+static
+#endif
+  SANE_Status
+gl125_end_scan (Genesys_Device * dev, Genesys_Register_Set * reg,
+        SANE_Bool check_stop);
+#ifndef UNIT_TESTING
+static
+#endif
+  SANE_Status
+gl125_slow_back_home (Genesys_Device * dev, SANE_Bool wait_until_home);
+#ifndef UNIT_TESTING
+static
+#endif
+SANE_Status gl125_init (Genesys_Device * dev);
+#ifndef UNIT_TESTING
+static
+#endif
+SANE_Status gl125_send_shading_data (Genesys_Device * dev, uint8_t * data, int size);
+
+#ifndef UNIT_TESTING
+static
+#endif
+SANE_Status gl125_feed (Genesys_Device * dev, unsigned int steps, int reverse);
+
+GENESYS_STATIC SANE_Status
+gl125_stop_action (Genesys_Device * dev);
+
+GENESYS_STATIC SANE_Status
+gl125_send_slope_table (Genesys_Device * dev, int table_nr,
+            uint16_t * slope_table, int steps);
+
+/* vim: set sw=2 cino=>2se-1sn-1s{s^-1st0(0u0 smarttab expandtab: */
diff --git a/backend/genesys_low.c b/backend/genesys_low.c
index 4cbd75d..5f2ef81 100644
--- a/backend/genesys_low.c
+++ b/backend/genesys_low.c
@@ -71,6 +71,8 @@ sanei_genesys_init_cmd_set (Genesys_Device * dev)
       return sanei_gl846_init_cmd_set (dev);
     case GENESYS_GL847:
       return sanei_gl847_init_cmd_set (dev);
+    case GENESYS_GL125:
+      return sanei_gl125_init_cmd_set (dev);
     case GENESYS_GL124:
       return sanei_gl124_init_cmd_set (dev);
     default:
@@ -312,6 +314,7 @@ sanei_genesys_write_register (Genesys_Device * dev, uint16_t reg, uint8_t val)
   if(dev->model->asic_type==GENESYS_GL847
   || dev->model->asic_type==GENESYS_GL845
   || dev->model->asic_type==GENESYS_GL846
+  || dev->model->asic_type==GENESYS_GL125
   || dev->model->asic_type==GENESYS_GL124)
     {
       return sanei_genesys_write_gl847_register(dev, reg, val);
@@ -435,6 +438,7 @@ sanei_genesys_read_register (Genesys_Device * dev, uint16_t reg, uint8_t * val)
   if(dev->model->asic_type==GENESYS_GL847
   || dev->model->asic_type==GENESYS_GL845
   || dev->model->asic_type==GENESYS_GL846
+  || dev->model->asic_type==GENESYS_GL125
   || dev->model->asic_type==GENESYS_GL124)
     return sanei_genesys_read_gl847_register(dev, reg, val);
 
@@ -479,6 +483,7 @@ sanei_genesys_set_buffer_address (Genesys_Device * dev, uint32_t addr)
   if(dev->model->asic_type==GENESYS_GL847
   || dev->model->asic_type==GENESYS_GL845
   || dev->model->asic_type==GENESYS_GL846
+  || dev->model->asic_type==GENESYS_GL125
   || dev->model->asic_type==GENESYS_GL124)
     {
       DBG (DBG_warn,
@@ -587,7 +592,7 @@ sanei_genesys_fe_write_data (Genesys_Device * dev, uint8_t addr,
   reg[1].value = (data / 256) & 0xff;
   reg[2].address = 0x3b;
   reg[2].value = data & 0xff;
-  if (dev->model->asic_type == GENESYS_GL124)
+  if (dev->model->asic_type == GENESYS_GL124 || GENESYS_GL125)
     {
      reg[1].address = 0x5d;
      reg[2].address = 0x5e;
@@ -624,7 +629,7 @@ sanei_genesys_get_status (Genesys_Device * dev, uint8_t * status)
     }
 #endif
 
-  if(dev->model->asic_type==GENESYS_GL124)
+  if(dev->model->asic_type==GENESYS_GL124 || GENESYS_GL125)
     return sanei_genesys_read_hregister(dev, 0x101, status);
   return sanei_genesys_read_register (dev, 0x41, status);
 }
@@ -731,6 +736,17 @@ sanei_genesys_read_valid_words (Genesys_Device * dev, unsigned int *words)
       *words = *words * 256 + value;
       break;
 
+    case GENESYS_GL125:
+      RIE (sanei_genesys_read_hregister (dev, 0x102, &value));
+      *words = (value & 0x03);
+      RIE (sanei_genesys_read_hregister (dev, 0x103, &value));
+      *words = *words * 256 + value;
+      RIE (sanei_genesys_read_hregister (dev, 0x104, &value));
+      *words = *words * 256 + value;
+      RIE (sanei_genesys_read_hregister (dev, 0x105, &value));
+      *words = *words * 256 + value;
+      break;
+
     default:
       RIE (sanei_genesys_read_register (dev, 0x44, &value));
       *words = value;
@@ -759,7 +775,7 @@ sanei_genesys_read_scancnt (Genesys_Device * dev, unsigned int *words)
 
   DBG (DBG_proc, "sanei_genesys_read_scancnt: start\n");
 
-  if (dev->model->asic_type == GENESYS_GL124)
+  if (dev->model->asic_type == GENESYS_GL124 || GENESYS_GL125)
     {
       RIE (sanei_genesys_read_hregister (dev, 0x10b, &value));
       *words = (value & 0x0f) << 16;
@@ -1050,7 +1066,7 @@ sanei_genesys_read_feed_steps (Genesys_Device * dev, unsigned int *steps)
 
   DBG (DBG_proc, "sanei_genesys_read_feed_steps\n");
 
-  if (dev->model->asic_type == GENESYS_GL124)
+  if (dev->model->asic_type == GENESYS_GL124 || GENESYS_GL125)
     {
       RIE (sanei_genesys_read_hregister (dev, 0x108, &value));
       *steps = (value & 0x1f) << 16;
diff --git a/backend/genesys_low.h b/backend/genesys_low.h
index 56627b4..b026f67 100644
--- a/backend/genesys_low.h
+++ b/backend/genesys_low.h
@@ -325,7 +325,7 @@ Genesys_Color_Order;
 #define GENESYS_GL845	 845
 #define GENESYS_GL846	 846
 #define GENESYS_GL847	 847
-#define GENESYS_GL848	 848
+#define GENESYS_GL125	 125
 #define GENESYS_GL123	 123
 #define GENESYS_GL124	 124
 
@@ -353,6 +353,7 @@ Genesys_Color_Order;
 #define DAC_PLUSTEK3800    19
 #define DAC_CANONLIDE80    20
 #define DAC_CANONLIDE120   21
+#define DAC_HPSJ200        22
 
 #define CCD_UMAX         0
 #define CCD_ST12         1	/* SONY ILX548: 5340 Pixel  ??? */
@@ -385,6 +386,7 @@ Genesys_Color_Order;
 #define CIS_CANONLIDE80  28
 #define CIS_CANONLIDE220 29
 #define CIS_CANONLIDE120 30
+#define CIS_HPSJ200      31  
 
 #define GPO_UMAX         0
 #define GPO_ST12         1
@@ -412,6 +414,7 @@ Genesys_Color_Order;
 #define GPO_PLUSTEK3800  23
 #define GPO_CANONLIDE80  24
 #define GPO_CANONLIDE120 25
+#define GPO_HPSJ200      26  
 
 #define MOTOR_UMAX          0
 #define MOTOR_5345          1
@@ -438,7 +441,7 @@ Genesys_Color_Order;
 #define MOTOR_CANONLIDE210 23
 #define MOTOR_CANONLIDE80  24
 #define MOTOR_CANONLIDE120 25
-
+#define MOTOR_HPSJ200      26  
 
 /* Forward typedefs */
 typedef struct Genesys_Device Genesys_Device;
@@ -1240,6 +1243,8 @@ extern SANE_Status sanei_gl841_init_cmd_set (Genesys_Device * dev);
 extern SANE_Status sanei_gl843_init_cmd_set (Genesys_Device * dev);
 extern SANE_Status sanei_gl846_init_cmd_set (Genesys_Device * dev);
 extern SANE_Status sanei_gl847_init_cmd_set (Genesys_Device * dev);
+//extern SANE_Status sanei_gl848_init_cmd_set (Genesys_Device * dev);
 extern SANE_Status sanei_gl124_init_cmd_set (Genesys_Device * dev);
+extern SANE_Status sanei_gl125_init_cmd_set (Genesys_Device * dev);
 
 #endif /* not GENESYS_LOW_H */
